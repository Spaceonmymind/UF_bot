import os
import json
import asyncio
import time
from dataclasses import dataclass
from typing import Optional, List, Tuple
from html import escape as h
import asyncpg
from dotenv import load_dotenv

from aiogram.client.default import DefaultBotProperties
from aiogram import Bot, Dispatcher, F
from aiogram.filters import Command, CommandObject
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder

load_dotenv()


TEST_MODE = False
TEST_USER_ID = 925918573



EVENT_CODE = os.environ.get("EVENT_CODE", "CONF2026").strip()
QUESTIONS_FILE = os.environ.get("QUESTIONS_FILE", "questions_CONF2026.json").strip()
QUESTION_DURATION_NS = int(os.environ.get("QUESTION_DURATION_NS", "60000000000"))
BOT_TOKEN = os.environ["BOT_TOKEN"]
DATABASE_URL = os.environ["DATABASE_URL"]
ADMIN_IDS = set(int(x.strip()) for x in os.environ.get("ADMIN_IDS", "").split(",") if x.strip())

BLITZ_DURATION_NS = 120_000_000_000  # 2 –º–∏–Ω—É—Ç—ã
BLITZ_QUESTIONS = [
    {
        "order_index": 1,
        "text": "–ß—Ç–æ –æ—Ç–ª–∏—á–∞–µ—Ç L7-DDoS –∞—Ç–∞–∫—É –æ—Ç –ø—Ä–æ—Å—Ç–æ –≤—Å–ø–ª–µ—Å–∫–∞ —Ç—Ä–∞—Ñ–∏–∫–∞ (–Ω–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç–∏ —Å–∏—Å—Ç–µ–º—ã)?",
        "options": [
            "–†–µ–∑–∫–∏–π —Ä–æ—Å—Ç –Ω–∞–≥—Ä—É–∑–∫–∏ –Ω–∞ ‚Äú–¥–æ—Ä–æ–≥–∏–µ‚Äù —Ñ—É–Ω–∫—Ü–∏–∏ (–ª–æ–≥–∏–Ω—ã, —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∏ —Ç.–ø.) –∏ –Ω–µ–µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø–æ–≤—Ç–æ—Ä—ã –≤ –∑–∞–ø—Ä–æ—Å–∞—Ö.",
            "–†–µ–∑–∫–∏–π —Ä–æ—Å—Ç –≤—Ö–æ–¥—è—â–µ–≥–æ —Ç—Ä–∞—Ñ–∏–∫–∞ –≤ –≥–∏–≥–∞–±–∞–π—Ç–∞—Ö.",
            "–£–≤–µ–ª–∏—á–µ–Ω–∏–µ —á–∏—Å–ª–∞ –æ—Ç–≤–µ—Ç–æ–≤ 200 OK –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞.",
            "–†–æ—Å—Ç –∫–µ—à-—Ö–∏—Ç–æ–≤ (–æ—Ç–≤–µ—Ç–æ–≤ –∏–∑ –∫–µ—à–∞).",
        ],
        "correct": "A",
    },
    {
        "order_index": 2,
        "text": "–ü–æ—á–µ–º—É –Ω–µ–ª—å–∑—è —Å—á–∏—Ç–∞—Ç—å –±—Ä–∞—É–∑–µ—Ä–Ω—ã–π fingerprint –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å—Ç–∞–±–∏–ª—å–Ω—ã–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º?",
        "options": [
            "–ü–æ—Ç–æ–º—É —á—Ç–æ ¬´—ç—Ç–æ –Ω–µ–∑–∞–∫–æ–Ω–Ω–æ¬ª.",
            "–ü–æ—Ç–æ–º—É —á—Ç–æ –æ—Ç–ø–µ—á–∞—Ç–æ–∫ –º–µ–Ω—è–µ—Ç—Å—è, —Å–æ–¥–µ—Ä–∂–∏—Ç —à—É–º –∏ –º–æ–∂–µ—Ç —Å–æ–≤–ø–∞–¥–∞—Ç—å —É —Ä–∞–∑–Ω—ã—Ö –ª—é–¥–µ–π; –±—Ä–∞—É–∑–µ—Ä—ã —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –º–µ—à–∞—é—Ç —Å—ä—ë–º—É –ø–æ—Å—Ç–æ—è–Ω–Ω—ã—Ö –æ—Ç–ø–µ—á–∞—Ç–∫–æ–≤.",
            "–ü–æ—Ç–æ–º—É —á—Ç–æ –±—Ä–∞—É–∑–µ—Ä—ã –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö API –¥–ª—è —Å—ä—ë–º–∞ –æ—Ç–ø–µ—á–∞—Ç–∫–∞.",
            "–ü–æ—Ç–æ–º—É —á—Ç–æ –Ω–∞–¥—ë–∂–Ω–µ–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –ø–æ IP-–∞–¥—Ä–µ—Å—É.",
        ],
        "correct": "B",
    },
    {
        "order_index": 3,
        "text": "–ö–∞–∫–æ–≤ –ø—Ä–∏–Ω—Ü–∏–ø –≤–≤–æ–¥–∞ captcha –≤ –≥—Ä–∞–º–æ—Ç–Ω–æ–π –∫–∏–±–µ—Ä–∑–∞—â–∏—Ç–µ?",
        "options": [
            "–ü—Ä–æ–≤–µ—Ä—è—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ—Å—Ç–æ—è–Ω–Ω–æ, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –∏—Ö –ø–æ–≤–µ–¥–µ–Ω–∏—è.",
            "–ü—Ä–æ–≤–µ—Ä—è—Ç—å —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, —É –ø–æ—Å—Ç–æ—è–Ω–Ω—ã—Ö –Ω–µ —Å–ø—Ä–∞—à–∏–≤–∞—Ç—å.",
            "–í–≤–æ–¥–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ –ø–æ —É—Ä–æ–≤–Ω—é —Ä–∏—Å–∫–∞ –∏ —Ç–æ–ª—å–∫–æ –Ω–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏—è—Ö.",
            "–í–∫–ª—é—á–∞—Ç—å –∫–∞–ø—á–∏ –∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —à–∞–≥–∏ —Ç–æ–ª—å–∫–æ –Ω–æ—á—å—é, –≤ –Ω–µ—Ä–∞–±–æ—á–∏–µ —á–∞—Å—ã.",
        ],
        "correct": "C",
    },
    {
        "order_index": 4,
        "text": "–ö–∞–∫–∞—è –º–µ—Ç—Ä–∏–∫–∞ –≤ –ø–µ—Ä–≤—É—é –æ—á–µ—Ä–µ–¥—å –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –∑–∞—â–∏—Ç–∞ —Ä–µ–∞–ª—å–Ω–æ –ø–æ–º–æ–≥–∞–µ—Ç –≤–æ –≤—Ä–µ–º—è L7-–∞—Ç–∞–∫–∏?",
        "options": [
            "–ó–∞–≥—Ä—É–∑–∫–∞ CPU –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ —Å—Ç–∞–ª–∞ –Ω–∏–∂–µ.",
            "–ß–∏—Å–ª–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö IP –≤—ã—Ä–æ—Å–ª–æ.",
            "–î–æ–ª—è —É—Å–ø–µ—à–Ω—ã—Ö –ª–µ–≥–∏—Ç–∏–º–Ω—ã—Ö –ª–æ–≥–∏–Ω–æ–≤ + p95 latency –Ω–∞ –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–∞—Ö (login/schedule/reset) —É–ª—É—á—à–∏–ª–∏—Å—å.",
            "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–∫–∞–∑–∞–Ω–Ω—ã—Ö –∫–∞–ø—á —É–º–µ–Ω—å—à–∏–ª–æ—Å—å.",
        ],
        "correct": "C",
    },
]


REVIEW_MAIN = {
    1: {
        "title": "–°–∏—Ç—É–∞—Ü–∏—è 1",
        "correct": "B",
        "question": "–ß—Ç–æ –ø—Ä–µ–¥–ø—Ä–∏–Ω–∏–º–∞–µ–º –≤ –ø–µ—Ä–≤—É—é –æ—á–µ—Ä–µ–¥—å, —á—Ç–æ–±—ã —É–¥–µ—Ä–∂–∞—Ç—å –≤ —Å—Ç–∞–±–∏–ª—å–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –∞—Ç–∞–∫—É–µ–º—É—é —Å–∏—Å—Ç–µ–º—É?",
        "options": {
            "A": "–≠–∫—Å—Ç—Ä–µ–Ω–Ω–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ ‚Äì —É–≤–µ–ª–∏—á–∏—Ç—å —Å–∫–µ–π–ª –≤ 5 —Ä–∞–∑.",
            "B": "–í–∫–ª—é—á–∏—Ç—å –∑–∞—â–∏—Ç—É –Ω–∞ –ø–µ—Ä–∏–º–µ—Ç—Ä–µ: –æ–≥—Ä–∞–Ω–∏—á–∏—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å –∑–∞–ø—Ä–æ—Å–æ–≤ (rate limiting) –∏ –¥–æ–±–∞–≤–∏—Ç—å –∫–∞–ø—á—É.",
            "C": "–û—Ç–∫–ª—é—á–∏—Ç—å –ø–æ–¥—Ä–æ–±–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ, —á—Ç–æ–±—ã —Å–Ω–∏–∑–∏—Ç—å –Ω–∞–≥—Ä—É–∑–∫—É –Ω–∞ –¥–∏—Å–∫–∏ –∏ –∂—É—Ä–Ω–∞–ª–∏—Ä–æ–≤–∞–Ω–∏–µ.",
            "D": "–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö (–æ–Ω–∞ —Ç–æ—Ä–º–æ–∑–∏—Ç —Å–∏—Å—Ç–µ–º—É).",
        },
        "explanations": {
            "A": "–ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ¬´–≤ –ª–æ–±¬ª —Ç–æ–ª—å–∫–æ –Ω–∞–∫–æ—Ä–º–∏—Ç –∞—Ç–∞–∫—É —Ä–µ—Å—É—Ä—Å–∞–º–∏. –†–∞–∑–≤–µ—Ä–Ω—É—Ç—å –≤–ø—è—Ç–µ—Ä–æ –±–æ–ª—å—à–µ –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤ –Ω–µ —É—Å–ø–µ–µ–º –º–≥–Ω–æ–≤–µ–Ω–Ω–æ, –∞ –≥–ª–∞–≤–Ω–æ–µ ‚Äì –±–µ–∑ –æ—Ç—Å–µ–≤–∞ –ª–∏—à–Ω–µ–≥–æ —Ç—Ä–∞—Ñ–∏–∫–∞ —ç—Ç–æ –¥–æ–±—å—ë—Ç –Ω–∞—à—É –ë–î –∏ —Å–µ—Ä–≤–∏—Å—ã (–∞—Ç–∞–∫–∞ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç —Ä–∞—Å—Ç–∏ –≤–º–µ—Å—Ç–µ —Å –º–∞—Å—à—Ç–∞–±–æ–º).",
            "B": "–°–Ω–∞—á–∞–ª–∞ –≥–∞—Å–∏–º –ª–∞–≤–∏–Ω—É –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ. –í–∫–ª—é—á–∞–µ–º –∑–∞—â–∏—Ç—É –Ω–∞ edge-—É—Ä–æ–≤–Ω–µ (CDN/WAF): –≤–≤–æ–¥–∏–º rate limiting –∏ ¬´–∏—Å–ø—ã—Ç–∞–Ω–∏–µ¬ª –¥–ª—è –±–æ—Ç–æ–≤ (–∫–∞–ø—á–∞ –∏–ª–∏ puzzle) –Ω–∞ —Å–∞–º—ã—Ö –¥–æ—Ä–æ–≥–∏—Ö –º–∞—Ä—à—Ä—É—Ç–∞—Ö (/login, —Å–±—Ä–æ—Å –ø–∞—Ä–æ–ª—è –∏ –ø—Ä.). –û—Ç—Å–µ–∏–≤–∞–µ–º –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π —Ç—Ä–∞—Ñ–∏–∫ –µ—â—ë –¥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ‚Äì –ø—É—Å—Ç—å –¥–æ –±–∞–∑—ã –¥–æ–ª–µ—Ç–∞—é—Ç —Ç–æ–ª—å–∫–æ —á–∏—Å—Ç—ã–µ –∑–∞–ø—Ä–æ—Å—ã. –≠—Ç–æ –≤—ã–∏–≥—Ä–∞–µ—Ç –Ω–∞–º –≤—Ä–µ–º—è –∏ —Å–ø–∞—Å—ë—Ç —è–¥—Ä–æ —Å–∏—Å—Ç–µ–º—ã –æ—Ç –ø–µ—Ä–µ–≥—Ä—É–∑–∫–∏.",
            "C": "–û—Ç–∫–ª—é—á–µ–Ω–∏–µ –ª–æ–≥–æ–≤ –Ω–µ —Ä–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É. –ù–∞–≥—Ä—É–∑–∫–∞ –∏–¥—ë—Ç –æ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–µ—Å—á–∏—Å–ª–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤, –∞ –Ω–µ –æ—Ç –∑–∞–ø–∏—Å–∏ –ª–æ–≥–æ–≤. –ö —Ç–æ–º—É –∂–µ, –±–µ–∑ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –º—ã –æ—Å–ª–µ–ø–Ω–µ–º –∏ –ø–æ—Ç–µ—Ä—è–µ–º —Ü–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ–± –∞—Ç–∞–∫–µ.",
            "D": "–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –Ω–∏–∫–∞–∫ –Ω–µ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç –∞—Ç–∞–∫—É ‚Äì –±–æ—Ç–Ω–µ—Ç –ø—Ä–æ–¥–æ–ª–∂–∏—Ç –±–æ–º–±–∞—Ä–¥–∏—Ä–æ–≤–∞—Ç—å —Å–µ—Ä–≤–∏—Å –ø–æ—Å–ª–µ —Ä–µ—Å—Ç–∞—Ä—Ç–∞. –ë–æ–ª–µ–µ —Ç–æ–≥–æ, —Ö–æ–ª–æ–¥–Ω—ã–π —Å—Ç–∞—Ä—Ç –ë–î –ø–æ–¥ –ª–∞–≤–∏–Ω–æ–π –∑–∞–ø—Ä–æ—Å–æ–≤ –º–æ–∂–µ—Ç —É—Å–∫–æ—Ä–∏—Ç—å –∫—Ä–∞—Ö —Å–∏—Å—Ç–µ–º—ã.",
        },
    },

    2: {
        "title": "–°–∏—Ç—É–∞—Ü–∏—è 2",
        "correct": "C",
        "question": "–ö–∞–∫ –¥–µ–π—Å—Ç–≤—É–µ–º, —á—Ç–æ–±—ã –æ—Ç–ª–∏—á–∏—Ç—å –±–æ—Ç–æ–≤ –æ—Ç –ª—é–¥–µ–π?",
        "options": {
            "B": "–í–≤–µ—Å—Ç–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –∂—ë—Å—Ç–∫–∏–π —Å—É–ø–µ—Ä-fingerprint (—Å–±–æ—Ä –¥–µ—Å—è—Ç–∫–æ–≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤: Canvas, AudioContext, WebGL, —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã –∏ —Ç.–ø.) –∏ –±–∞–Ω–∏—Ç—å –Ω–∞–≤—Å–µ–≥–¥–∞ –≤—Å–µ —Ö–æ—Å—Ç—ã, —É –∫–æ—Ç–æ—Ä—ã—Ö —Ü–∏—Ñ—Ä–æ–≤–æ–π –æ—Ç–ø–µ—á–∞—Ç–æ–∫ –≤—ã–∑—ã–≤–∞–µ—Ç –º–∞–ª–µ–π—à–∏–µ –ø–æ–¥–æ–∑—Ä–µ–Ω–∏—è.",
            "C": "–ó–∞–ø—Ä–µ—Ç–∏—Ç—å –≤—Ö–æ–¥ –≤ —Å–∏—Å—Ç–µ–º—É –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã —á–µ—Ä–µ–∑ –º–æ–±–∏–ª—å–Ω—ã–π —Å–µ—Ç–∏ (3G/4G/5G).",
            "A": "–ü–µ—Ä–µ–π—Ç–∏ –Ω–∞ risk-based –ø–æ–¥—Ö–æ–¥: —Å–æ–±–∏—Ä–∞—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ ¬´–æ—Ç–ø–µ—á–∞—Ç–∫–∏¬ª + –ø–æ–≤–µ–¥–µ–Ω—á–µ—Å–∫–∏–µ —Ñ–∞–∫—Ç–æ—Ä—ã, –≤—ã—á–∏—Å–ª—è—Ç—å —Ä–∏—Å–∫-—Å–∫–æ—Ä–∏–Ω–≥ –∫–∞–∂–¥–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞ –∏ –ø—Ä–∏ –≤—ã—Å–æ–∫–æ–º —Ä–∏—Å–∫–µ –≤–∫–ª—é—á–∞—Ç—å —Ç–æ—á–µ—á–Ω—ã–µ —É—Å–∏–ª–µ–Ω–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∏–ª–∏ –∫–∞–ø—á—É).",
            "D": "–ü—Ä–∏–≤—è–∑–∞—Ç—å –ª–∏–º–∏—Ç—ã –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –Ω–µ–∏–∑–º–µ–Ω–Ω—ã–º –∞—Ç—Ä–∏–±—É—Ç–∞–º HTTP-–∑–∞–ø—Ä–æ—Å–æ–≤: –Ω–∞–ø—Ä–∏–º–µ—Ä, –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å User-Agent –∏ Accept-Language –∫–∞–∂–¥–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ –∏ –≤–≤–æ–¥–∏—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –Ω–∞ –∏—Ö –æ—Å–Ω–æ–≤–µ.",
        },
        "explanations": {
            "A": "–í—Å–µ–æ–±—ä–µ–º–ª—é—â–∏–π –±–∞–Ω –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ fingerprint —Å–∫–æ—Ä–µ–µ –Ω–∞–≤—Ä–µ–¥—è—Ç. –ê–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π —Ç—Ä–µ–∫–∏–Ω–≥ –Ω–∞—Ä—É—à–∞–µ—Ç –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å –∏ –º–æ–∂–µ—Ç –¥–∞—Ç—å —Å–±–æ–∏: —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –±–æ—Ç—ã –º–æ–≥—É—Ç –º–∞—Å–∫–∏—Ä–æ–≤–∞—Ç—å –º–Ω–æ–≥–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –∞ –º—ã —Ä–∏—Å–∫—É–µ–º –æ—Ç–∫–ª—é—á–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑-–∑–∞ —Å–ª—É—á–∞–π–Ω—ã—Ö —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π.",
            "B": "–ë–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ—Ö –º–æ–±–∏–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π ‚Äî —Å–ª–∏—à–∫–æ–º —Ä–∞–¥–∏–∫–∞–ª—å–Ω–æ –∏ –Ω–µ–æ–ø—Ä–∞–≤–¥–∞–Ω–Ω–æ. –ë–æ–ª—å—à–∞—è —á–∞—Å—Ç—å –∫–ª–∏–µ–Ω—Ç–æ–≤ –∑–∞—Ö–æ–¥–∏—Ç —Å —Ç–µ–ª–µ—Ñ–æ–Ω–æ–≤, –∏—Ö –Ω–µ–ª—å–∑—è –ø—Ä–æ—Å—Ç–æ –æ—Ç—Ä–µ–∑–∞—Ç—å. –ö —Ç–æ–º—É –∂–µ –±–æ—Ç–Ω–µ—Ç –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏ –∫–∞–±–µ–ª—å–Ω—ã—Ö –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤. –ú—ã –±—ã –ø—Ä–æ—Å—Ç–æ —Å–∞–º–∏ —É—Å—Ç—Ä–æ–∏–ª–∏ ¬´DDoS¬ª –¥–ª—è –ª–µ–≥–∏—Ç–∏–º–Ω—ã—Ö –º–æ–±–∏–ª—å–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤.",
            "C": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥: —Å–æ–±–∏—Ä–∞–µ–º –ª–∏—à—å ¬´–º—è–≥–∫–∏–µ¬ª —Å–∏–≥–Ω–∞–ª—ã ‚Äî –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –æ—Ç–ø–µ—á–∞—Ç–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –±–∞–∑–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –±—Ä–∞—É–∑–µ—Ä–∞) –∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –ø–æ–≤–µ–¥–µ–Ω–∏–µ (–Ω–µ–µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ –±—ã—Å—Ç—Ä—ã–µ –∫–ª–∏–∫–∏, –ø–æ–≤—Ç–æ—Ä—è–µ–º–æ—Å—Ç—å –¥–µ–π—Å—Ç–≤–∏–π). –ù–∞ –æ—Å–Ω–æ–≤–µ —ç—Ç–∏—Ö –¥–∞–Ω–Ω—ã—Ö —Å—á–∏—Ç–∞–µ–º —Ä–∏—Å–∫. –ï—Å–ª–∏ —Å–æ–≤–æ–∫—É–ø–Ω—ã–π —Ä–∏—Å–∫ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –ø–æ—Ä–æ–≥ ‚Äî –≤–∫–ª—é—á–∞–µ–º –±–æ–ª–µ–µ –∂—ë—Å—Ç–∫—É—é –ø—Ä–æ–≤–µ—Ä–∫—É (—Ç–∞–∫ –Ω–∞–∑—ã–≤–∞–µ–º—ã–π step-up: –∫–∞–ø—á–∞, –¥–≤—É—Ö—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∏ –ø—Ä.). –ï—Å–ª–∏ –Ω–µ—Ç ‚Äî –Ω–µ —Ç—Ä–æ–≥–∞–µ–º —á–µ–ª–æ–≤–µ–∫–∞ –ª–∏—à–Ω–∏–º–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞–º–∏. –¢–∞–∫–æ–π –ø–æ–¥—Ö–æ–¥ –ø–æ–∑–≤–æ–ª—è–µ—Ç –º–∏–Ω–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–ª–µ–∂–∫—É –∑–∞ –¥–æ–±—Ä–æ–ø–æ—Ä—è–¥–æ—á–Ω—ã–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏, –Ω–æ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –ª–æ–≤–∏—Ç—å –±–æ—Ç–æ–≤.",
            "D": "–ü—Ä–∏–≤—è–∑–∫–∞ –ª–∏–º–∏—Ç–æ–≤ –∫ User-Agent –∏ —è–∑—ã–∫—É ‚Äî —Å–ª–∏—à–∫–æ–º –ø—Ä–∏–º–∏—Ç–∏–≤–Ω–æ. –ë–æ—Ç –º–æ–∂–µ—Ç —Ä–∞–Ω–¥–æ–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –∏–ª–∏ –∏–º–∏—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è. –ê –≤–æ—Ç —Ä–µ–∞–ª—å–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —á–∞—Å—Ç–æ –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ User-Agent (–Ω–∞–ø—Ä–∏–º–µ—Ä, –º–Ω–æ–∂–µ—Å—Ç–≤–æ –ª—é–¥–µ–π —Å–∏–¥–∏—Ç –Ω–∞ Chrome –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –≤–µ—Ä—Å–∏–π) –∏ —è–∑—ã–∫. –≠—Ç–æ—Ç –∫—Ä–∏—Ç–µ—Ä–∏–π —Å–ª–∞–±—ã–π –∏ –º–æ–∂–µ—Ç –∫–∞–∫ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞, —Ç–∞–∫ –∏ —É–¥–∞—Ä–∏—Ç—å –ø–æ —Ä–µ–∞–ª—å–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.",
        },
    },

    3: {
        "title": "–°–∏—Ç—É–∞—Ü–∏—è 3",
        "correct": "B",
        "question": "–ö–∞–∫ —Ä–∞–∑–æ–±–ª–∞—á–∏—Ç—å –∏ –Ω–µ–π—Ç—Ä–∞–ª–∏–∑–æ–≤–∞—Ç—å –∞—Ç–∞–∫—É, –∫–æ—Ç–æ—Ä–∞—è –º–∞—Å–∫–∏—Ä—É–µ—Ç—Å—è –ø–æ–¥ –ª–µ–≥–∏—Ç–∏–º–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π?",
        "options": {
            "A": "–ü—Ä–∏–º–µ–Ω–∏—Ç—å –≥–µ–æ–±–ª–æ–∫–∏—Ä–æ–≤–∫—É: –æ—Ç–∫–ª—é—á–∏—Ç—å –≤–µ—Å—å —Ç—Ä–∞—Ñ–∏–∫ –∏–∑ –∏–Ω–æ—Å—Ç—Ä–∞–Ω–Ω—ã—Ö —Ä–µ–≥–∏–æ–Ω–æ–≤, –æ—Å—Ç–∞–≤–∏—Ç—å –¥–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –∏–∑ –†–§.",
            "B": "–°–æ–ø–æ—Å—Ç–∞–≤–ª—è—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã TLS –∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å HTTP-–∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ —Å –ø–æ–≤–µ–¥–µ–Ω–∏–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –∏—Ö —Å–µ—Å—Å–∏—è–º–∏ (first-party cookies/token). –ü—Ä–∏ –º–∞–ª–µ–π—à–∏—Ö –∞–Ω–æ–º–∞–ª–∏—è—Ö –≤–∫–ª—é—á–∞—Ç—å Proof-of-Work –∫–∞–ø—á–∏.",
            "C": "–£–≤–µ–ª–∏—á–∏—Ç—å —Ç–∞–π–º–∞—É—Ç—ã –∏ –æ—á–µ—Ä–µ–¥–∏ –Ω–∞ –±—ç–∫–µ–Ω–¥–µ, —á—Ç–æ–±—ã –∫–∞–∂–¥—ã–π –∑–∞–ø—Ä–æ—Å –¥–æ–ª—å—à–µ –∂–¥–∞–ª –æ—Ç–≤–µ—Ç–∞. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –∑–∞–º–µ–¥–ª–∏—Ç—å –≤—Å–µ—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ –∏ –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –ø–µ—Ä–µ–∂–¥–∞—Ç—å –Ω–∞—Ç–∏—Å–∫.",
            "D": "–í–≤–µ—Å—Ç–∏ –∫–∞–ø—á—É –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–∞ –∫–∞–∂–¥—ã–π –∑–∞–ø—Ä–æ—Å/–¥–µ–π—Å—Ç–≤–∏–µ –¥–æ –∫–æ–Ω—Ü–∞ –∞—Ç–∞–∫–∏, —á—Ç–æ–±—ã –æ—Ç—Å–µ—è—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Å–∫—Ä–∏–ø—Ç—ã.",
        },
        "explanations": {
            "A": "–û—Ç–∫–ª—é—á–∏—Ç—å ¬´–≤–µ—Å—å –º–∏—Ä¬ª ‚Äì —Ç–æ–ø–æ—Ä–Ω—ã–π —à–∞–≥. –ê—Ç–∞–∫–∞ –º–æ–∂–µ—Ç –≤–µ—Å—Ç–∏—Å—å –∏ –∏–∑ –Ω–∞—à–µ–≥–æ —Ä–µ–≥–∏–æ–Ω–∞, —á–µ—Ä–µ–∑ –≤–∑–ª–æ–º–∞–Ω–Ω—ã–µ –æ—Ç–µ—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Å–µ—Ä–≤–µ—Ä–∞ –∏–ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞, –ª–∏–±–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –ø–æ –≤—Å–µ–º—É –º–∏—Ä—É. –ú—ã —Ä–∏—Å–∫—É–µ–º –æ—Ç—Ä–µ–∑–∞—Ç—å –ª–µ–≥–∏—Ç–∏–º–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–ª–∏–µ–Ω—Ç–æ–≤ –∏–∑ –¥—Ä—É–≥–∏—Ö —Å—Ç—Ä–∞–Ω –∏–ª–∏ —Ç–µ—Ö, –∫—Ç–æ –∑–∞—à—ë–ª —á–µ—Ä–µ–∑ VPN), –Ω–æ –Ω–µ —Å—Ç–æ–ø—Ä–æ—Ü–µ–Ω—Ç–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–∏–º –±–æ—Ç–Ω–µ—Ç.",
            "B": "–ö–æ–≥–¥–∞ –∞—Ç–∞–∫—É—é—â–∏–µ –º–µ–Ω—è—é—Ç IP –∫–∞–∫ –ø–µ—Ä—á–∞—Ç–∫–∏, –º—ã –∏—â–µ–º –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç—ã –Ω–∞ —É—Ä–æ–≤–Ω–µ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –∏ –ø–æ–≤–µ–¥–µ–Ω–∏—è. –£ –∫–∞–∂–¥–æ–≥–æ –±—Ä–∞—É–∑–µ—Ä–∞ –µ—Å—Ç—å —Å–≤–æ–π –Ω–µ–≤–∏–¥–∏–º—ã–π ¬´–ø–æ—á–µ—Ä–∫¬ª ‚Äì –ø–æ—Ä—è–¥–æ–∫ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤, –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ TLS-handshake, –≤–ø–ª–æ—Ç—å –¥–æ –æ—à–∏–±–æ–∫ –≤ –∑–∞–ø—Ä–æ—Å–∞—Ö. –£ –Ω–∞—à–∏—Ö –±–æ—Ç–æ–≤ —ç—Ç–∏ –ø—Ä–∏–∑–Ω–∞–∫–∏ —Å–æ–≤–ø–∞–¥–∞—é—Ç, —á—Ç–æ –∏—Ö –∏ –≤—ã–¥–∞—ë—Ç. –ö–æ—Ä—Ä–µ–ª–∏—Ä—É—è —ç—Ç–∏ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –æ—Ç–ø–µ—á–∞—Ç–∫–∏ —Å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞–º–∏ —Å–µ—Å—Å–∏–π (–∫—É–∫–∏, —Ç–æ–∫–µ–Ω—ã) –º—ã —Å–≥—Ä—É–ø–ø–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å—ã, –ø–æ–Ω–∏–º–∞—è, –≥–¥–µ —Ç—ã—Å—è—á–µ–π –ª–∏—Ü –æ—Ä—É–¥—É–µ—Ç –æ–¥–∏–Ω ¬´–±–æ—Å—Å¬ª. –î–∞–ª–µ–µ —É—Å–∏–ª–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–ª—è –Ω–∏—Ö —Å–ª–æ–∂–Ω–æ—Å—Ç—å –¥–æ—Å—Ç—É–ø–∞: –ø–æ–¥–∫–ª—é—á–∞–µ–º –∫–∞–ø—á–∏, –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –∑–∞–¥–∞—á–∏ –∏–ª–∏ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å–ª–æ–∂–Ω–æ—Å—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–æ–≤ (Proof-of-Work), —á—Ç–æ–±—ã –±–æ—Ç–Ω–µ—Ç—É —Å—Ç–∞–ª–æ –Ω–∞–∫–ª–∞–¥–Ω–æ –∞—Ç–∞–∫–æ–≤–∞—Ç—å. –í–∞–∂–Ω–æ: –æ–±—ã—á–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —ç—Ç–æ–≥–æ –Ω–µ –ø–æ—á—É–≤—Å—Ç–≤—É—é—Ç ‚Äì –¥–ª—è –Ω–∏—Ö –≤—Å—ë —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ —Ä–∞–±–æ—Ç–∞–ª–æ.",
            "C": "–ó–∞–¥–µ—Ä–∂–∏–≤–∞—Ç—å –æ—Ç–≤–µ—Ç—ã –¥–ª—è –≤—Å–µ—Ö ‚Äì –ø–ª–æ—Ö–∞—è –∏–¥–µ—è. –î–∞, –±–æ—Ç–Ω–µ—Ç –º–æ–∂–µ—Ç ¬´—É—Å—Ç–∞—Ç—å¬ª –∂–¥–∞—Ç—å, –Ω–æ —Ä–µ–∞–ª—å–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Ç–æ–∂–µ. –ö —Ç–æ–º—É –∂–µ –∑–∞–ø—Ä–æ—Å—ã –Ω–µ –∏—Å—á–µ–∑–∞—é—Ç, –∞ –≤–∏—Å—è—Ç –≤ –æ—á–µ—Ä–µ–¥–∏, –≥—Ä—É–∑—è —Å–∏—Å—Ç–µ–º—É. –°–∫–æ—Ä–µ–µ –Ω–∞—à –ø–æ—Ä—Ç–∞–ª –ª—è–∂–µ—Ç –æ—Ç —Ç–∞–∫–∏—Ö –∑–∞–¥–µ—Ä–∂–µ–∫, –∞ –Ω–µ –∞—Ç–∞–∫–∞ –ø—Ä–µ–∫—Ä–∞—Ç–∏—Ç—Å—è.",
            "D": "–ö–∞–ø—á–∞ –Ω–∞ –∫–∞–∂–¥—ã–π —á–∏—Ö –º–≥–Ω–æ–≤–µ–Ω–Ω–æ —É–±—å—ë—Ç –ª–æ—è–ª—å–Ω–æ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π. –õ—é–¥–∏ –Ω–µ –±—É–¥—É—Ç —Ä–µ—à–∞—Ç—å –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ —Ä–∞–±–æ—Ç—ã —Å —Å–µ—Ä–≤–∏—Å–æ–º ‚Äì –º—ã —Å–∞–º–∏ —Ç–∞–∫–∏–º —Ä–µ—à–µ–Ω–∏–µ–º —É—Å—Ç—Ä–æ–∏–º –æ—Ç–∫–∞–∑ –≤ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–∏ –¥–ª—è –≤—Å–µ—Ö. –ê —É–º–Ω—ã–µ –±–æ—Ç—ã –∏ –∫–∞–ø—á—É –º–æ–≥—É—Ç –æ–±—Ö–æ–¥–∏—Ç—å, —Ç–∞–∫ —á—Ç–æ —Ç–∞–∫–æ–π —Ä–µ–∂–∏–º –∫–æ–Ω—Ç—Ä–æ–ª—è –ª–∏—à—å –Ω–∞–≤—Ä–µ–¥–∏—Ç –ª–µ–≥–∏—Ç–∏–º–Ω—ã–º –∫–ª–∏–µ–Ω—Ç–∞–º.",
        },
    },
}

REVIEW_BLITZ = {
    1: {
        "title": "–ë–ª–∏—Ü Q1",
        "correct": "A",
        "question": "–ß—Ç–æ –æ—Ç–ª–∏—á–∞–µ—Ç L7-DDoS –∞—Ç–∞–∫—É –æ—Ç –ø—Ä–æ—Å—Ç–æ –≤—Å–ø–ª–µ—Å–∫–∞ —Ç—Ä–∞—Ñ–∏–∫–∞ (–Ω–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç–∏ —Å–∏—Å—Ç–µ–º—ã)?",
        "options": {
            "A": "–†–µ–∑–∫–∏–π —Ä–æ—Å—Ç –Ω–∞–≥—Ä—É–∑–∫–∏ –Ω–∞ ‚Äú–¥–æ—Ä–æ–≥–∏–µ‚Äù —Ñ—É–Ω–∫—Ü–∏–∏ (–ª–æ–≥–∏–Ω—ã, —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∏ —Ç.–ø.) –∏ –Ω–µ–µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø–æ–≤—Ç–æ—Ä—ã –≤ –∑–∞–ø—Ä–æ—Å–∞—Ö.",
            "B": "–†–µ–∑–∫–∏–π —Ä–æ—Å—Ç –≤—Ö–æ–¥—è—â–µ–≥–æ —Ç—Ä–∞—Ñ–∏–∫–∞ –≤ –≥–∏–≥–∞–±–∞–π—Ç–∞—Ö.",
            "C": "–£–≤–µ–ª–∏—á–µ–Ω–∏–µ —á–∏—Å–ª–∞ –æ—Ç–≤–µ—Ç–æ–≤ 200 OK –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞.",
            "D": "–†–æ—Å—Ç –∫–µ—à-—Ö–∏—Ç–æ–≤ (–æ—Ç–≤–µ—Ç–æ–≤ –∏–∑ –∫–µ—à–∞).",
        },
        "explanations": {
            "A": "L7-DDoS –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ –∏—Å—Ç–æ—â–µ–Ω–∏–µ –∏–º–µ–Ω–Ω–æ —Ç—è–∂—ë–ª—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π (–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è, –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö) –∏ –≤—ã–¥–∞—ë—Ç —Å–µ–±—è –Ω–µ—Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ—Å—Ç—å—é –ø–æ URL –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º. –í–∞–∂–µ–Ω –Ω–µ –æ–±—â–∏–π –æ–±—ä—ë–º —Ç—Ä–∞—Ñ–∏–∫–∞, –∞ –∫—É–¥–∞ –±—å—ë—Ç –∞—Ç–∞–∫–∞ –∏ —Å –∫–∞–∫–æ–π –∞–Ω–æ–º–∞–ª—å–Ω–æ–π —á–∞—Å—Ç–æ—Ç–æ–π.",
            "B": "–û–±—â–∏–π –æ–±—ä—ë–º —Ç—Ä–∞—Ñ–∏–∫–∞ –º–æ–∂–µ—Ç –≤—ã—Ä–∞—Å—Ç–∏ –∏ –ø–æ —á–µ—Å—Ç–Ω—ã–º –ø—Ä–∏—á–∏–Ω–∞–º (–Ω–æ–≤–æ—Å—Ç–∏, –¥–µ–¥–ª–∞–π–Ω, —Ä–∞—Å—Å—ã–ª–∫–∞). –î–ª—è L7 –≤–∞–∂–Ω–µ–µ –Ω–µ ¬´—Å–∫–æ–ª—å–∫–æ –≥–∏–≥–∞–±–∞–π—Ç¬ª, –∞ –∫–∞–∫–∏–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã/–æ–ø–µ—Ä–∞—Ü–∏–∏ –ø–µ—Ä–µ–≥—Ä—É–∂–∞—é—Ç —Å–∏—Å—Ç–µ–º—É.",
            "C": "200 OK –Ω–µ –¥–æ–∫–∞–∑—ã–≤–∞–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∞—Ç–∞–∫–∏: –∞—Ç–∞–∫—É—é—â–∏–µ –º–æ–≥—É—Ç –ø–æ–ª—É—á–∞—Ç—å 200 –Ω–∞ –¥–µ—à—ë–≤—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü–∞—Ö –∏–ª–∏ –¥–∞–∂–µ –Ω–∞ –¥–æ—Ä–æ–≥–∏—Ö, –ø–æ–∫–∞ —Å–µ—Ä–≤–∏—Å –¥–µ–≥—Ä–∞–¥–∏—Ä—É–µ—Ç –¥–ª—è —á–∞—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.",
            "D": "–†–æ—Å—Ç –∫–µ—à-—Ö–∏—Ç–æ–≤ —Å–∫–æ—Ä–µ–µ –≥–æ–≤–æ—Ä–∏—Ç, —á—Ç–æ –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤ –æ–±—Å–ª—É–∂–∏–≤–∞–µ—Ç—Å—è –∫–µ—à–µ–º. –≠—Ç–æ –º–æ–∂–µ—Ç –¥–∞–∂–µ –ø–æ–º–æ—á—å –ø–µ—Ä–µ–∂–∏—Ç—å –≤—Å–ø–ª–µ—Å–∫ –∏ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏–∑–Ω–∞–∫–æ–º L7-–∏—Å—Ç–æ—â–µ–Ω–∏—è —Ç—è–∂—ë–ª—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π.",
        },
    },

    2: {
        "title": "–ë–ª–∏—Ü Q2",
        "correct": "B",
        "question": "–ü–æ—á–µ–º—É –Ω–µ–ª—å–∑—è —Å—á–∏—Ç–∞—Ç—å –±—Ä–∞—É–∑–µ—Ä–Ω—ã–π fingerprint –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å—Ç–∞–±–∏–ª—å–Ω—ã–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º?",
        "options": {
            "A": "–ü–æ—Ç–æ–º—É —á—Ç–æ ¬´—ç—Ç–æ –Ω–µ–∑–∞–∫–æ–Ω–Ω–æ¬ª.",
            "B": "–ü–æ—Ç–æ–º—É —á—Ç–æ –æ—Ç–ø–µ—á–∞—Ç–æ–∫ –º–µ–Ω—è–µ—Ç—Å—è, —Å–æ–¥–µ—Ä–∂–∏—Ç —à—É–º –∏ –º–æ–∂–µ—Ç —Å–æ–≤–ø–∞–¥–∞—Ç—å —É —Ä–∞–∑–Ω—ã—Ö –ª—é–¥–µ–π; –±—Ä–∞—É–∑–µ—Ä—ã —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –º–µ—à–∞—é—Ç —Å—ä—ë–º—É –ø–æ—Å—Ç–æ—è–Ω–Ω—ã—Ö –æ—Ç–ø–µ—á–∞—Ç–∫–æ–≤.",
            "C": "–ü–æ—Ç–æ–º—É —á—Ç–æ –±—Ä–∞—É–∑–µ—Ä—ã –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö API –¥–ª—è —Å—ä—ë–º–∞ –æ—Ç–ø–µ—á–∞—Ç–∫–∞.",
            "D": "–ü–æ—Ç–æ–º—É —á—Ç–æ –Ω–∞–¥—ë–∂–Ω–µ–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –ø–æ IP-–∞–¥—Ä–µ—Å—É.",
        },
        "explanations": {
            "A": "–°–∞–º –ø–æ —Å–µ–±–µ fingerprint –Ω–µ ¬´–≤—Å–µ–≥–¥–∞ –Ω–µ–∑–∞–∫–æ–Ω–µ–Ω¬ª: —é—Ä–∏–¥–∏—á–µ—Å–∫–∏–µ –Ω—é–∞–Ω—Å—ã –∑–∞–≤–∏—Å—è—Ç –æ—Ç —é—Ä–∏—Å–¥–∏–∫—Ü–∏–∏ –∏ –ø—Ä–∞–∫—Ç–∏–∫–∏. –ì–ª–∞–≤–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞ ‚Äî —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å –∏ –ª–æ–∂–Ω—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è.",
            "B": "Fingerprint ‚Äì —à—Ç—É–∫–∞ –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–∞—è: –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å –±—Ä–∞—É–∑–µ—Ä –∏–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–æ–≤–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ, –∏ —Ü–∏—Ñ—Ä–æ–≤–æ–π –æ—Ç–ø–µ—á–∞—Ç–æ–∫ –∏–∑–º–µ–Ω–∏—Ç—Å—è. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, —Ç–µ—Ö–Ω–∏–∫–∏ –∞–Ω—Ç–∏-—Ñ–∏–Ω–≥–µ—Ä–ø—Ä–∏–Ω—Ç–∏–Ω–≥–∞ (–Ω–∞–ø—Ä. —Ä–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö) –¥–µ–ª–∞—é—Ç –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ–ø–æ—Å—Ç–æ—è–Ω–Ω—ã–º. –û–Ω —Ö–æ—Ä–æ—à –∫–∞–∫ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π —Å–∏–≥–Ω–∞–ª, –Ω–æ –ø—Ä–∏–≤—è–∑—ã–≤–∞—Ç—å—Å—è –∫ –Ω–µ–º—É –Ω–∞ 100% –Ω–µ–ª—å–∑—è.",
            "C": "API –¥–ª—è —Å–∏–≥–Ω–∞–ª–æ–≤ –µ—Å—Ç—å (—á–∞—Å—Ç–∏—á–Ω–æ), –Ω–æ –º–Ω–æ–≥–∏–µ –¥–∞–Ω–Ω—ã–µ —Å—Ç–∞–ª–∏ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—Ç—å—Å—è/—à—É–º–µ—Ç—å. –ü—Ä–æ–±–ª–µ–º–∞ –Ω–µ —Ç–æ–ª—å–∫–æ –≤ API, –∞ –≤ —Ç–æ–º, —á—Ç–æ —Å–∏–≥–Ω–∞–ª –º–µ–Ω—è–µ—Ç—Å—è –∏ –∏—Å–∫–∞–∂–∞–µ—Ç—Å—è.",
            "D": "IP –µ—â—ë –º–µ–Ω–µ–µ –Ω–∞–¥—ë–∂–µ–Ω: NAT, –º–æ–±–∏–ª—å–Ω—ã–µ —Å–µ—Ç–∏, VPN, –ø—Ä–æ–∫—Å–∏, –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∞–¥—Ä–µ—Å–∞. IP –ø–æ–ª–µ–∑–µ–Ω –∫–∞–∫ —Ñ–∞–∫—Ç–æ—Ä, –Ω–æ —Å—Ç–∞–±–∏–ª—å–Ω—ã–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º –Ω–µ —è–≤–ª—è–µ—Ç—Å—è.",
        },
    },

    3: {
        "title": "–ë–ª–∏—Ü Q3",
        "correct": "C",
        "question": "–ö–∞–∫–æ–≤ –ø—Ä–∏–Ω—Ü–∏–ø –≤–≤–æ–¥–∞ captcha –≤ –≥—Ä–∞–º–æ—Ç–Ω–æ–π –∫–∏–±–µ—Ä–∑–∞—â–∏—Ç–µ?",
        "options": {
            "A": "–ü—Ä–æ–≤–µ—Ä—è—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ—Å—Ç–æ—è–Ω–Ω–æ, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –∏—Ö –ø–æ–≤–µ–¥–µ–Ω–∏—è.",
            "B": "–ü—Ä–æ–≤–µ—Ä—è—Ç—å —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, —É –ø–æ—Å—Ç–æ—è–Ω–Ω—ã—Ö –Ω–µ —Å–ø—Ä–∞—à–∏–≤–∞—Ç—å.",
            "C": "–í–≤–æ–¥–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ –ø–æ —É—Ä–æ–≤–Ω—é —Ä–∏—Å–∫–∞ –∏ —Ç–æ–ª—å–∫–æ –Ω–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏—è—Ö.",
            "D": "–í–∫–ª—é—á–∞—Ç—å –∫–∞–ø—á–∏ –∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —à–∞–≥–∏ —Ç–æ–ª—å–∫–æ –Ω–æ—á—å—é, –≤ –Ω–µ—Ä–∞–±–æ—á–∏–µ —á–∞—Å—ã.",
        },
        "explanations": {
            "A": "–ü–æ—Å—Ç–æ—è–Ω–Ω—ã–µ –∫–∞–ø—á–∏ —É–±—å—é—Ç –∫–æ–Ω–≤–µ—Ä—Å–∏—é/UX –∏ –¥–∞–¥—É—Ç –∞—Ç–∞–∫—É—é—â–∏–º –ø–æ–Ω–∏–º–∞–Ω–∏–µ –≤–∞—à–∏—Ö –±–∞—Ä—å–µ—Ä–æ–≤. –ó–∞—â–∏—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ç–æ—á–µ—á–Ω–æ–π –∏ —ç–∫–æ–Ω–æ–º–Ω–æ–π.",
            "B": "¬´–¢–æ–ª—å–∫–æ –Ω–æ–≤—ã–º¬ª ‚Äî —É–ø—Ä–æ—â–µ–Ω–∏–µ: –±–æ—Ç—ã –±—ã–≤–∞—é—Ç –∏ ¬´—Å—Ç–∞—Ä—ã–º–∏¬ª (—É–≥–Ω–∞–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã, –ø—Ä–æ–≥—Ä–µ—Ç—ã–µ –∫—É–∫–∏). –ù—É–∂–µ–Ω —Ä–∏—Å–∫-–ø–æ–¥—Ö–æ–¥, –∞ –Ω–µ –≤–æ–∑—Ä–∞—Å—Ç –∞–∫–∫–∞—É–Ω—Ç–∞.",
            "C": "–õ–∏—à–Ω–∏–µ –±–∞—Ä—å–µ—Ä—ã –Ω–µ —Å—Ç–∞–≤–∏–º –±–µ–∑ –ø—Ä–∏—á–∏–Ω—ã: –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —à–∞–≥–∏ –Ω—É–∂–Ω—ã —Ç–æ–≥–¥–∞ –∏ —Ç–∞–º, –≥–¥–µ –µ—Å—Ç—å –∞–Ω–æ–º–∞–ª–∏—è –∏–ª–∏ –≤—ã—Å–æ–∫–∞—è —Ü–µ–Ω–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–∏. –ò–¥–µ–∞–ª ‚Äì 99% –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–∞–∂–µ –Ω–µ —É–∑–Ω–∞—é—Ç –æ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–∏ –∫–∞–ø—á–∏, –ø–æ–∫–∞ –Ω–µ –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç —á—Ç–æ-—Ç–æ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ–µ.",
            "D": "–ê—Ç–∞–∫–∏ –Ω–µ –æ–±—è–∑–∞–Ω—ã –±—ã—Ç—å ¬´–Ω–æ—á—å—é¬ª. –ü—Ä–∏–≤—è–∑–∫–∞ –∫ –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫ –Ω–µ –ª–æ–≤–∏—Ç –∞–Ω–æ–º–∞–ª–∏–∏ –∏ –º–æ–∂–µ—Ç –æ—Å—Ç–∞–≤–∏—Ç—å –¥—ã—Ä—É –¥–Ω—ë–º, –∫–æ–≥–¥–∞ –Ω–∞–≥—Ä—É–∑–∫–∞ –∏ —É—â–µ—Ä–± –≤—ã—à–µ.",
        },
    },

    4: {
        "title": "–ë–ª–∏—Ü Q4",
        "correct": "C",
        "question": "–ö–∞–∫–∞—è –º–µ—Ç—Ä–∏–∫–∞ –≤ –ø–µ—Ä–≤—É—é –æ—á–µ—Ä–µ–¥—å –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –∑–∞—â–∏—Ç–∞ —Ä–µ–∞–ª—å–Ω–æ –ø–æ–º–æ–≥–∞–µ—Ç –≤–æ –≤—Ä–µ–º—è L7-–∞—Ç–∞–∫–∏?",
        "options": {
            "A": "–ó–∞–≥—Ä—É–∑–∫–∞ CPU –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ —Å—Ç–∞–ª–∞ –Ω–∏–∂–µ.",
            "B": "–ß–∏—Å–ª–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö IP –≤—ã—Ä–æ—Å–ª–æ.",
            "C": "–î–æ–ª—è —É—Å–ø–µ—à–Ω—ã—Ö –ª–µ–≥–∏—Ç–∏–º–Ω—ã—Ö –ª–æ–≥–∏–Ω–æ–≤ + p95 latency –Ω–∞ –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–∞—Ö (login/schedule/reset) —É–ª—É—á—à–∏–ª–∏—Å—å.",
            "D": "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–∫–∞–∑–∞–Ω–Ω—ã—Ö –∫–∞–ø—á —É–º–µ–Ω—å—à–∏–ª–æ—Å—å.",
        },
        "explanations": {
            "A": "CPU ‚Äî –ø–æ–ª–µ–∑–Ω—ã–π —Å–∏–º–ø—Ç–æ–º, –Ω–æ –ª–µ–≥–∫–æ –æ–±–º–∞–Ω—á–∏–≤—ã–π: –≤—ã –º–æ–∂–µ—Ç–µ —Å–Ω–∏–∑–∏—Ç—å CPU, ‚Äú—É–±–∏–≤‚Äù —Å–µ—Ä–≤–∏—Å –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∂—ë—Å—Ç–∫–æ –æ—Ç—Ä–µ–∑–∞–≤ —Ç—Ä–∞—Ñ–∏–∫ –∏–ª–∏ —É—Ä–æ–Ω–∏–≤ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å). –≠—Ç–æ –Ω–µ –º–µ—Ç—Ä–∏–∫–∞ —É—Å–ø–µ—Ö–∞ –∑–∞—â–∏—Ç—ã, –∞ –ª–∏—à—å –æ–¥–∏–Ω –∏–∑ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ —Å–æ—Å—Ç–æ—è–Ω–∏—è.",
            "B": "‚Äú–ë–æ–ª—å—à–µ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫‚Äù –Ω–µ —Ä–∞–≤–Ω–æ ‚Äú–ª—É—á—à–µ –∑–∞—â–∏—Ç–∞‚Äù: –º–æ–∂–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª–æ–≤–∏–Ω—É –∞—É–¥–∏—Ç–æ—Ä–∏–∏ –∏ –≥–æ—Ä–¥–æ —Ä–∞–ø–æ—Ä—Ç–æ–≤–∞—Ç—å –æ–± —É—Å–ø–µ—Ö–µ. –í–∞–∂–Ω–æ, —á—Ç–æ–±—ã –ø—Ä–æ—Ö–æ–¥–∏–ª–∏ —Å–≤–æ–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏, –∞ –Ω–µ —á—Ç–æ–±—ã —Ä–æ—Å–ª–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫.",
            "C": "–£—Å–ø–µ—Ö –≤ –º–æ–º–µ–Ω—Ç –∞—Ç–∞–∫–∏ ‚Äî —ç—Ç–æ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –¥–ª—è –ª–µ–≥–∏—Ç–∏–º–Ω—ã—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–æ—Ü–µ–Ω—Ç —É—Å–ø–µ—à–Ω—ã—Ö –ª–æ–≥–∏–Ω–æ–≤) –∏ –∫–∞—á–µ—Å—Ç–≤–æ —Å–µ—Ä–≤–∏—Å–∞ –Ω–∞ —Å–∞–º—ã—Ö –≤–∞–∂–Ω—ã—Ö –º–∞—Ä—à—Ä—É—Ç–∞—Ö (p95 –∑–∞–¥–µ—Ä–∂–∫–∏ / –æ—à–∏–±–∫–∏ –Ω–∞ login/schedule/reset). –ò–º–µ–Ω–Ω–æ —ç—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –≤—ã –Ω–µ –ø—Ä–æ—Å—Ç–æ ‚Äú–¥–µ—Ä—ë—Ç–µ—Å—å‚Äù, –∞ —Ä–µ–∞–ª—å–Ω–æ —Å–ø–∞—Å–∞–µ—Ç–µ —Å–∏—Å—Ç–µ–º—É –¥–ª—è –ª—é–¥–µ–π.",
            "D": "–ö–∞–ø—á –º–æ–∂–µ—Ç —Å—Ç–∞—Ç—å –º–µ–Ω—å—à–µ, –ø–æ—Ç–æ–º—É —á—Ç–æ –≤—ã –∏—Ö –æ—Ç–∫–ª—é—á–∏–ª–∏ (–∏–ª–∏ –ø–æ—Ç–æ–º—É —á—Ç–æ –∞—Ç–∞–∫–∞ –∏–∑–º–µ–Ω–∏–ª–∞ –ø–æ–≤–µ–¥–µ–Ω–∏–µ), –Ω–æ —ç—Ç–æ –Ω–µ –¥–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –∑–∞—â–∏—Ç–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç.  ‚Äî —ç—Ç–æ –ª–∏—à—å –æ–¥–∏–Ω –∏–∑ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–µ–π. –ï–≥–æ –æ–¥–Ω–æ–≥–æ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–π –æ—Ü–µ–Ω–∫–∏ —Å–∏—Ç—É–∞—Ü–∏–∏.",
        },
    },
}

MSG_ALL = (
    '<b>–°–ª–µ–¥–∏—Ç–µ –∑–∞ –Ω–æ–≤–æ—Å—Ç—è–º–∏ –æ —Å—Ç–∞–∂–∏—Ä–æ–≤–∫–∞—Ö –ê–û ¬´–ù–°–ü–ö¬ª</b>\n'
    '–≤ —á–∞—Ç–µ <a href="https://t.me/+ppFf1m34Jc9iOTVi">'
    '¬´–ò–Ω–Ω–æ–≤–∞—Ü–∏–∏ –≤ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è—Ö –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö —Å–∏—Å—Ç–µ–º¬ª</a> üí¨\n\n'

    '<b>–ó–¥–µ—Å—å –≤—ã –Ω–∞–π–¥—ë—Ç–µ:</b>\n'
    '‚Ä¢ –æ–±—â–µ–Ω–∏–µ —Å —ç–∫—Å–ø–µ—Ä—Ç–∞–º–∏ –æ—Ç—Ä–∞—Å–ª–∏\n'
    '‚Ä¢ —Å–≤–µ–∂–∏–µ –Ω–æ–≤–æ—Å—Ç–∏ –∏ –∫–µ–π—Å—ã –∏–∑ –º–∏—Ä–∞ —Ñ–∏–Ω—Ç–µ—Ö–∞\n'
    '‚Ä¢ —É—á–µ–±–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã\n\n'

    '–°–æ–∑–¥–∞–¥–∏–º –±—É–¥—É—â–µ–µ —Ñ–∏–Ω—Ç–µ—Ö–∞ –≤–º–µ—Å—Ç–µ!üîù'
)

MSG_TOP10 = (
    "üèÜ <b>–¢–æ–ø-10</b>\n\n"
    "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –Ω–∞–±—Ä–∞–ª–∏ –Ω–∞–∏–±–æ–ª—å—à–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∞–ª–ª–æ–≤ "
    "–∏ –∑–∞—á–∏—Å–ª–µ–Ω—ã –Ω–∞ —É—á–µ–±–Ω—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É "
    "¬´–ò–Ω–Ω–æ–≤–∞—Ü–∏–∏ –≤ —Ñ–∏–Ω—Ç–µ—Ö–µ ‚Äî —Ç–µ–æ—Ä–∏—è –∏ –ø—Ä–∞–∫—Ç–∏–∫–∞¬ª 2026‚Äì2027.\n\n"
    "üëâ <a href=\"https://t.me/+Y6mRsQWD_Fo4YTQy\">"
    "–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ —á–∞—Ç—É –∫—É—Ä—Å–∞</a>"
)


MSG_TOP5 = (
    "ü•á <b>–¢–æ–ø-5</b>\n\n"
    "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –≤–æ—à–ª–∏ –≤ <b>—Ç–æ–ø-5</b> –ø–æ –∏—Ç–æ–≥–∞–º —Ä–µ—à–µ–Ω–∏—è –∫–µ–π—Å–∞ –∏ –±–ª–∏—Ü–∞!\n\n"
    "üé§ –ü—Ä–∏–≥–ª–∞—à–∞–µ–º –≤–∞—Å –Ω–∞ —Å—Ü–µ–Ω—É!"
)



# --- Helpers ---------------------------------------------------------

def is_admin(user_id: int) -> bool:
    return user_id in ADMIN_IDS

def fmt_duration_ns(ns: int) -> str:
    # –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤ —Å–µ–∫—É–Ω–¥–∞—Ö —Å –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞–º–∏
    ms = ns / 1_000_000
    sec = ms / 1000.0
    return f"{sec:0.3f}s"

async def send_long(bot: Bot, chat_id: int, text: str, chunk: int = 3800):
    # Telegram limit ~4096
    for i in range(0, len(text), chunk):
        await bot.send_message(chat_id, text[i:i+chunk])

def answer_kb(session_code: str, q_index: int):
    kb = InlineKeyboardBuilder()
    for opt in ["A", "B", "C", "D"]:
        kb.button(text=opt, callback_data=f"ans:{session_code}:{q_index}:{opt}")
    kb.adjust(4)
    return kb.as_markup()

def admin_menu_kb(session_code: str):
    kb = InlineKeyboardBuilder()
    kb.button(text="‚û°Ô∏è –°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å (60—Å)", callback_data=f"adm:next:{session_code}")
    kb.button(text="‚ö° –ó–∞–ø—É—Å—Ç–∏—Ç—å –±–ª–∏—Ü (2 –º–∏–Ω)", callback_data=f"adm:blitz:{session_code}")
    kb.button(text="üèÅ –ò—Ç–æ–≥–∏", callback_data=f"adm:finish:{session_code}")
    kb.button(text="üì£ –°—Ç–∞–∂–∏—Ä–æ–≤–∫–∏", callback_data=f"broadcast:all:{session_code}"),
    kb.button(text="üèÖ –¢–æ–ø-10: –∫—É—Ä—Å", callback_data=f"broadcast:top10:{session_code}"),
    kb.button(text="ü•á –¢–æ–ø-5: –Ω–∞ —Å—Ü–µ–Ω—É", callback_data=f"broadcast:top5:{session_code}"),
    kb.button(text="üîÑ –°–±—Ä–æ—Å–∏—Ç—å —Å–µ—Å—Å–∏—é", callback_data=f"adm:reset:{session_code}")
    kb.adjust(2, 2, 1)
    return kb.as_markup()

async def send_review_menu_to_admin(bot: Bot, admin_chat_id: int, session_code: str):
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üìò –†–∞–∑–±–æ—Ä: –º–µ–Ω—é", callback_data=f"rev:menu:{session_code}")]
    ])
    await bot.send_message(
        admin_chat_id,
        "‚ö° –ë–ª–∏—Ü –∑–∞–≤–µ—Ä—à—ë–Ω. –ú–æ–∂–Ω–æ –æ—Ç–∫—Ä—ã—Ç—å —Ä–∞–∑–±–æ—Ä –≤–æ–ø—Ä–æ—Å–æ–≤:",
        reply_markup=kb
    )

def confirm_reset_kb(session_code: str):
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –î–∞, —Å–±—Ä–æ—Å–∏—Ç—å", callback_data=f"adm:reset_yes:{session_code}")
    kb.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data=f"adm:reset_no:{session_code}")
    kb.adjust(2)
    return kb.as_markup()

def admin_sessions_kb(rows):
    kb = InlineKeyboardBuilder()

    if not rows:
        kb.button(text="–ù–µ—Ç —Å–µ—Å—Å–∏–π", callback_data="noop")
        return kb.as_markup()

    for r in rows:
        emoji = {
            "waiting": "üü°",
            "live": "üü¢",
            "finished": "‚ö´"
        }.get(r["status"], "‚ö™")

        kb.button(
            text=f"{emoji} {r['code']}",
            callback_data=f"admopen:{r['code']}"
        )

    kb.adjust(1)
    return kb.as_markup()

def blitz_answer_kb(session_code: str, q_index: int):
    kb = InlineKeyboardBuilder()
    for opt in ["A", "B", "C", "D"]:
        kb.button(text=opt, callback_data=f"blitz:{session_code}:{q_index}:{opt}")
    kb.adjust(4)
    return kb.as_markup()

def render_question_text(set_name: str, idx: int) -> str:
    data = REVIEW_MAIN if set_name == "main" else REVIEW_BLITZ
    q = data[idx]
    lines = []
    lines.append(f"<b>{h(q['title'])}</b>")
    lines.append("")
    lines.append(h(q["question"]))
    lines.append("")
    for letter in ("A", "B", "C", "D"):
        opt = q["options"][letter]
        mark = "‚úÖ " if letter == q["correct"] else ""
        lines.append(f"{mark}<b>{letter})</b> {h(opt)}")
    lines.append("")
    lines.append(f"‚úÖ <b>–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç:</b> {h(q['correct'])}")
    return "\n".join(lines)


def render_explanations_text(set_name: str, idx: int) -> str:
    data = REVIEW_MAIN if set_name == "main" else REVIEW_BLITZ
    q = data[idx]
    lines = [f"<b>{h(q['title'])} ‚Äî —Ä–∞–∑–±–æ—Ä</b>", ""]
    for letter in ("A", "B", "C", "D"):
        exp = q["explanations"][letter]
        mark = "‚úÖ " if letter == q["correct"] else ""
        lines.append(f"{mark}<b>{letter})</b> {h(exp)}")
        lines.append("")
    return "\n".join(lines).strip()


def kb_review_root(code: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üéØ –ê—Ç–∞–∫–∞ (–°–∏—Ç—É–∞—Ü–∏–∏ 1‚Äì3)", callback_data=f"rev:set:{code}:main")],
        [InlineKeyboardButton(text="‚ö° –ë–ª–∏—Ü (Q1‚ÄìQ4)", callback_data=f"rev:set:{code}:blitz")],
        [InlineKeyboardButton(text="‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data=f"rev:close:{code}")],
    ])


def kb_review_set(code: str, set_name: str) -> InlineKeyboardMarkup:
    data = REVIEW_MAIN if set_name == "main" else REVIEW_BLITZ
    rows = []
    for idx in sorted(data.keys()):
        rows.append([InlineKeyboardButton(
            text=f"{data[idx]['title']}",
            callback_data=f"rev:q:{code}:{set_name}:{idx}"
        )])
    rows.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data=f"rev:menu:{code}")])
    return InlineKeyboardMarkup(inline_keyboard=rows)


def kb_review_question(code: str, set_name: str, idx: int) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üìñ –ü–æ–∫–∞–∑–∞—Ç—å –æ–±—ä—è—Å–Ω–µ–Ω–∏—è", callback_data=f"rev:e:{code}:{set_name}:{idx}")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É", callback_data=f"rev:set:{code}:{set_name}")],
        [InlineKeyboardButton(text="üè† –í –º–µ–Ω—é", callback_data=f"rev:menu:{code}")],
    ])


def kb_review_explanations(code: str, set_name: str, idx: int) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –≤–æ–ø—Ä–æ—Å—É", callback_data=f"rev:q:{code}:{set_name}:{idx}")],
        [InlineKeyboardButton(text="üè† –í –º–µ–Ω—é", callback_data=f"rev:menu:{code}")],
    ])


# --- DB layer --------------------------------------------------------

@dataclass
class Question:
    order_index: int
    text: str
    a: str
    b: str
    c: str
    d: str
    correct: str

class DB:
    def __init__(self):
        self.pool: Optional[asyncpg.Pool] = None

    @staticmethod
    def _now_ns() -> int:
        import time
        return time.time_ns()

    async def connect(self):
        self.pool = await asyncpg.create_pool(DATABASE_URL, min_size=1, max_size=10)

    async def close(self):
        if self.pool:
            await self.pool.close()

    async def init_schema(self):
        assert self.pool
        with open("schema.sql", "r", encoding="utf-8") as f:
            sql = f.read()
        async with self.pool.acquire() as conn:
            await conn.execute(sql)

    async def list_sessions(self):
        assert self.pool
        async with self.pool.acquire() as conn:
            rows = await conn.fetch("""
                SELECT code, status
                FROM quiz_sessions
                ORDER BY id DESC
                LIMIT 20
            """)
            return rows

    async def get_session_users(self, session_id: int) -> list[int]:
        """–°–ø–∏—Å–æ–∫ tg_user_id –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —Å–µ—Å—Å–∏–∏."""
        assert self.pool
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                "SELECT DISTINCT tg_user_id FROM participants WHERE session_id=$1",
                session_id
            )
            return [int(r["tg_user_id"]) for r in rows]


    async def get_session_state(self, code: str):
        """–¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–µ—Å—Å–∏–∏ –¥–ª—è –ª–æ–≥–∏–∫–∏ —Ñ–∏–Ω–∏—à–∞/–ø—É–ª—å—Ç–∞."""
        assert self.pool
        async with self.pool.acquire() as conn:
            return await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1", code)

    async def mark_blitz_finished(self, session_code: str) -> bool:
        """–°—Ç–∞–≤–∏—Ç blitz_deadline_ns=NULL, —á—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –±–ª–∏—Ü–∞ –Ω–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–ª–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ."""
        assert self.pool
        async with self.pool.acquire() as conn:
            res = await conn.execute(
                """
                UPDATE quiz_sessions
                SET blitz_deadline_ns=NULL
                WHERE code=$1 AND blitz_deadline_ns IS NOT NULL
                """,
                session_code
            )
            # res –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ "UPDATE 1"
            return res.endswith("1")

    async def start_next_question(self, code: str, set_name: str = "main"):
        """
        –ü–µ—Ä–µ–≤–æ–¥–∏—Ç —Å–µ—Å—Å–∏—é –≤ live, —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç current_question_index,
        —Å—Ç–∞–≤–∏—Ç question_start_ns/question_deadline_ns –Ω–∞ –æ—Å–Ω–æ–≤–µ question_duration_ns.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (status, session_id, new_q_index, deadline_ns).
        """
        assert self.pool
        async with self.pool.acquire() as conn:
            async with conn.transaction():
                s = await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1 FOR UPDATE", code)
                if not s:
                    return "no_session", None, None, None

                session_id = int(s["id"])
                duration_ns = int(s["question_duration_ns"] or 60_000_000_000)

                new_q = int(s["current_question_index"] or 0) + 1
                start = self._now_ns()
                deadline = start + duration_ns

                await conn.execute(
                    """
                    UPDATE quiz_sessions
                    SET status='live',
                        current_question_index=$2,
                        question_start_ns=$3,
                        question_deadline_ns=$4
                    WHERE id=$1
                    """,
                    session_id, new_q, start, deadline
                )

                return "ok", session_id, new_q, deadline

    async def clear_blitz_deadline(self, session_id: int):
        assert self.pool
        async with self.pool.acquire() as conn:
            await conn.execute(
                "UPDATE quiz_sessions SET blitz_deadline_ns=NULL WHERE id=$1",
                session_id
            )

    async def start_blitz(self, code: str, duration_ns: int = 120_000_000_000):
        """
        –ó–∞–ø—É—Å–∫–∞–µ—Ç –±–ª–∏—Ü: —Å—Ç–∞–≤–∏—Ç blitz_start_ns/blitz_deadline_ns.
        –¢–∞–∫–∂–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç blitz_index —É—á–∞—Å—Ç–Ω–∏–∫–∞–º –≤ 0.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (status, session_id, deadline_ns).
        """
        assert self.pool
        async with self.pool.acquire() as conn:
            async with conn.transaction():
                s = await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1 FOR UPDATE", code)
                if not s:
                    return "no_session", None, None

                session_id = int(s["id"])
                start = start = self._now_ns()
                deadline = start + int(duration_ns)

                await conn.execute(
                    """
                    UPDATE quiz_sessions
                    SET blitz_start_ns=$2,
                        blitz_deadline_ns=$3
                    WHERE id=$1
                    """,
                    session_id, start, deadline
                )

                # —á—Ç–æ–±—ã "–ø—Ä–æ–π–¥–µ–Ω –±–ª–∏—Ü" –æ–ø—Ä–µ–¥–µ–ª—è–ª—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
                await conn.execute(
                    "UPDATE participants SET blitz_index=0 WHERE session_id=$1",
                    session_id
                )

                return "ok", session_id, deadline

    async def compute_leaderboard(self, session_code: str, limit: Optional[int] = None) -> Tuple[int, List[asyncpg.Record]]:
        """
        –õ–∏–¥–µ—Ä–±–æ—Ä–¥ –ø–æ —Å—É–º–º–µ MAIN + BLITZ (–ø–æ correct_cnt, –∑–∞—Ç–µ–º total_ns).
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (total_roster, rows).
        """
        assert self.pool
        async with self.pool.acquire() as conn:
            s = await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1", session_code)
            if not s:
                return 0, []
            session_id = int(s["id"])

            limit_sql = ""
            if isinstance(limit, int) and limit > 0:
                limit_sql = f"LIMIT {int(limit)}"

            rows = await conn.fetch(
                f"""
                SELECT
                  p.tg_user_id,
                  COALESCE(p.tg_username,'') AS username,
                  COALESCE(p.display_name,'') AS display_name,
                  COALESCE(SUM(CASE WHEN a.is_correct THEN 1 ELSE 0 END), 0) AS correct_cnt,
                  COALESCE(SUM(CASE WHEN a.is_correct THEN a.delta_ns ELSE 0 END), 0) AS total_ns,
                  COUNT(a.id) AS answered_cnt
                FROM participants p
                LEFT JOIN answers a 
                  ON a.participant_id=p.id 
                 AND a.session_id=$1
                 -- –í–ê–ñ–ù–û: –≤–∫–ª—é—á–∞–µ–º –∏ main, –∏ blitz
                 AND a.set IN ('main','blitz')
                WHERE p.session_id=$1
                GROUP BY p.tg_user_id, p.tg_username, p.display_name
                ORDER BY correct_cnt DESC, total_ns ASC, answered_cnt DESC
                {limit_sql}
                """,
                session_id
            )

            total = await conn.fetchval(
                "SELECT COUNT(*) FROM participants WHERE session_id=$1",
                session_id
            )
            return int(total or 0), rows

    async def count_blitz_finished(self, session_id: int) -> int:
        """
        –°–∫–æ–ª—å–∫–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ roster (–∏, –º–æ–∂–Ω–æ, active) —É–∂–µ –∑–∞–≤–µ—Ä—à–∏–ª–∏ –±–ª–∏—Ü:
        blitz_index=0 –ø—Ä–∏ —Ç–æ–º —á—Ç–æ –±–ª–∏—Ü –±—ã–ª –∑–∞–ø—É—â–µ–Ω (—Å—Ç–∞—Ä—Ç/–¥–µ–¥–ª–∞–π–Ω –µ—Å—Ç—å).
        """
        assert self.pool
        async with self.pool.acquire() as conn:
            v = await conn.fetchval(
                """
                SELECT COUNT(*) 
                FROM participants
                WHERE session_id=$1
                  AND blitz_index=0
                """,
                session_id
            )
            return int(v or 0)


    async def get_participant_stats(self, session_id: int) -> int:
        """returns joined_total (—Å–∫–æ–ª—å–∫–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –≤ —Å–µ—Å—Å–∏–∏)"""
        assert self.pool
        async with self.pool.acquire() as conn:
            joined = await conn.fetchval("SELECT COUNT(*) FROM participants WHERE session_id=$1", session_id)
            return int(joined or 0)

    async def count_answered_for_question(
        self,
        session_id: int,
        q_index: int,
        set_name: str = "main",
    ) -> int:
        """–°–∫–æ–ª—å–∫–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —É–∂–µ –æ—Ç–≤–µ—Ç–∏–ª–æ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –≤–æ–ø—Ä–æ—Å (–ø–æ session_id)."""
        assert self.pool
        async with self.pool.acquire() as conn:
            v = await conn.fetchval(
                """
                SELECT COUNT(*) FROM answers
                WHERE session_id=$1 AND set=$2 AND question_index=$3
                """,
                session_id, set_name, q_index
            )
            return int(v or 0)


    async def ensure_event(self, code: str, duration_ns: int):
        assert self.pool
        async with self.pool.acquire() as conn:
            await conn.execute("""
                INSERT INTO quiz_sessions(code, status, current_question_index, question_duration_ns)
                VALUES($1,'waiting',0,$2)
                ON CONFLICT (code) DO UPDATE
                SET question_duration_ns=EXCLUDED.question_duration_ns
            """, code, duration_ns)


    async def load_questions_from_json(self, session_code: str, path: str, set_name: str = "main"):
        assert self.pool
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
        async with self.pool.acquire() as conn:
            async with conn.transaction():
                # upsert questions
                for item in data:
                    opts = item["options"]
                    await conn.execute(
                        """
                        INSERT INTO questions(session_code, set, order_index, text, opt_a, opt_b, opt_c, opt_d, correct)
                        VALUES($1,$2,$3,$4,$5,$6,$7,$8,$9)
                        ON CONFLICT (session_code, set, order_index)
                        DO UPDATE SET text=EXCLUDED.text, opt_a=EXCLUDED.opt_a, opt_b=EXCLUDED.opt_b,
                                     opt_c=EXCLUDED.opt_c, opt_d=EXCLUDED.opt_d, correct=EXCLUDED.correct
                        """,
                        session_code, set_name, int(item["order_index"]), item["text"],
                        opts[0], opts[1], opts[2], opts[3], item["correct"]
                    )

    async def get_session(self, code: str):
        assert self.pool
        async with self.pool.acquire() as conn:
            return await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1", code)

    async def create_session(self, code: str):
        assert self.pool
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                INSERT INTO quiz_sessions(code, status, current_question_index)
                VALUES($1,'waiting',0)
                ON CONFLICT (code) DO UPDATE SET code=EXCLUDED.code
                RETURNING *
                """, code
            )
            return row

    async def join_participant(self, session_id: int, user_id: int, username: Optional[str], display_name: str):
        assert self.pool
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                INSERT INTO participants(session_id, tg_user_id, tg_username, display_name)
                VALUES($1,$2,$3,$4)
                ON CONFLICT(session_id, tg_user_id)
                DO UPDATE SET tg_username=EXCLUDED.tg_username, display_name=EXCLUDED.display_name
                RETURNING *, (xmax = 0) AS inserted
                """,
                session_id, user_id, username, display_name
            )
            return row


    async def set_blitz_index_for_user(self, session_id: int, tg_user_id: int, blitz_index: int = 1):
        """–°—Ç–∞–≤–∏—Ç —É—á–∞—Å—Ç–Ω–∏–∫—É blitz_index (–æ–±—ã—á–Ω–æ 1), –µ—Å–ª–∏ —É—á–∞—Å—Ç–Ω–∏–∫ –µ—Å—Ç—å –∏ blitz_index —Å–µ–π—á–∞—Å 0."""
        assert self.pool
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                UPDATE participants
                SET blitz_index=$3
                WHERE session_id=$1 AND tg_user_id=$2 AND blitz_index=0
                """,
                session_id, tg_user_id, blitz_index
            )

    async def get_questions_count(self, session_code: str, set_name: str = "main") -> int:
        assert self.pool
        async with self.pool.acquire() as conn:
            v = await conn.fetchval("SELECT COUNT(*) FROM questions WHERE session_code=$1 AND set=$2", session_code, set_name)
            return int(v or 0)

    async def load_blitz_from_const(self, session_code: str):
        assert self.pool
        async with self.pool.acquire() as conn:
            async with conn.transaction():
                for item in BLITZ_QUESTIONS:
                    opts = item["options"]
                    await conn.execute(
                        """
                        INSERT INTO questions(session_code, set, order_index, text, opt_a, opt_b, opt_c, opt_d, correct)
                        VALUES($1,'blitz',$2,$3,$4,$5,$6,$7,$8)
                        ON CONFLICT (session_code, set, order_index)
                        DO UPDATE SET text=EXCLUDED.text, opt_a=EXCLUDED.opt_a, opt_b=EXCLUDED.opt_b,
                                     opt_c=EXCLUDED.opt_c, opt_d=EXCLUDED.opt_d, correct=EXCLUDED.correct
                        """,
                        session_code, int(item["order_index"]), item["text"],
                        opts[0], opts[1], opts[2], opts[3], item["correct"]
                    )

    async def get_question(self, session_code: str, order_index: int, set_name: str = "main") -> Optional[Question]:
        assert self.pool
        async with self.pool.acquire() as conn:
            r = await conn.fetchrow(
                "SELECT * FROM questions WHERE session_code=$1 AND set=$2 AND order_index=$3",
                session_code, set_name, order_index
            )
            if not r:
                return None
            return Question(
                order_index=r["order_index"],
                text=r["text"],
                a=r["opt_a"],
                b=r["opt_b"],
                c=r["opt_c"],
                d=r["opt_d"],
                correct=r["correct"]
            )

    async def get_session_users(self, session_id: int) -> List[int]:
        assert self.pool
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                "SELECT tg_user_id FROM participants WHERE session_id=$1 ORDER BY id",
                session_id
            )
            return [int(r["tg_user_id"]) for r in rows]


    async def record_answer_and_maybe_advance(
            self,
            session_code: str,
            tg_user_id: int,
            q_index: int,
            chosen: str
    ) -> str:
        """
        Records answer if valid.
        No auto-advance anymore (admin controls /next).
        """
        assert self.pool
        async with self.pool.acquire() as conn:
            async with conn.transaction():
                s = await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1 FOR UPDATE", session_code)
                if not s:
                    return "not_live"
                await conn.execute("SELECT pg_advisory_xact_lock($1)", int(s["id"]))

                s = await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1 FOR UPDATE", session_code)
                if s["status"] != "live":
                    return "not_live"

                # –ø—Ä–∏–Ω–∏–º–∞–µ–º –æ—Ç–≤–µ—Ç—ã —Ç–æ–ª—å–∫–æ –Ω–∞ —Ç–µ–∫—É—â–∏–π –≤–æ–ø—Ä–æ—Å
                if int(s["current_question_index"]) != int(q_index):
                    return "closed"

                p = await conn.fetchrow(
                    "SELECT * FROM participants WHERE session_id=$1 AND tg_user_id=$2",
                    s["id"], tg_user_id
                )

                if not p:
                    return "not_in_session"

                q = await conn.fetchrow(
                    "SELECT correct FROM questions WHERE session_code=$1 AND set='main' AND order_index=$2",
                    session_code, q_index
                )
                if not q:
                    return "closed"

                now_ns = time.time_ns()
                deadline_ns = s["question_deadline_ns"]

                if deadline_ns is not None and int(now_ns) > int(deadline_ns):
                    # –¥–µ–¥–ª–∞–π–Ω –ø—Ä–æ—à—ë–ª ‚Äî –Ω–µ –ø—Ä–∏–Ω–∏–º–∞–µ–º
                    return "timeout"

                start_ns = int(s["question_start_ns"] or now_ns)
                delta_ns = int(now_ns - start_ns)
                is_correct = (chosen == q["correct"])

                res = await conn.execute(
                    """
                    INSERT INTO answers(
                      session_id, participant_id, set, question_index,
                      chosen, is_correct, received_ns, delta_ns, answered_after_deadline
                    )
                    VALUES($1,$2,'main',$3,$4,$5,$6,$7,false)
                    ON CONFLICT (participant_id, set, question_index) DO NOTHING
                    """,
                    s["id"], p["id"], q_index, chosen, is_correct, now_ns, delta_ns
                )

                # asyncpg –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫—É –≤–∏–¥–∞: "INSERT 0 1" –∏–ª–∏ "INSERT 0 0"
                if not res.endswith("1"):
                    return "duplicate"

                return "accepted"

    async def get_session_state(self, code: str):
        assert self.pool
        async with self.pool.acquire() as conn:
            return await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1", code)

    async def start_blitz(self, session_code: str) -> Tuple[str, Optional[int], Optional[int]]:
        """
        Sets blitz_start_ns/blitz_deadline_ns and sets participants.blitz_index=1 for roster.
        Returns (status, session_id, deadline_ns)
        status: ok|not_live
        """
        assert self.pool
        async with self.pool.acquire() as conn:
            async with conn.transaction():
                s = await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1 FOR UPDATE", session_code)
                if not s:
                    return "not_live", None, None

                # –µ—Å–ª–∏ waiting ‚Äî —Å—Ç–∞—Ä—Ç—É–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ (–º–æ–∂–Ω–æ –∑–∞–ø—É—Å–∫–∞—Ç—å –±–ª–∏—Ü –±–µ–∑ main)
                if s["status"] == "waiting":
                    await conn.execute(
                        """
                        UPDATE quiz_sessions
                        SET status='live', started_at=now()
                        WHERE id=$1
                        """,
                        s["id"]
                    )
                    s = await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1 FOR UPDATE", session_code)

                if s["status"] != "live":
                    return "not_live", None, None

                await conn.execute("SELECT pg_advisory_xact_lock($1)", int(s["id"]))
                s = await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1 FOR UPDATE", session_code)


                start_ns = time.time_ns()
                deadline_ns = start_ns + BLITZ_DURATION_NS

                await conn.execute(
                    """
                    UPDATE quiz_sessions
                    SET blitz_start_ns=$2, blitz_deadline_ns=$3
                    WHERE id=$1
                    """,
                    s["id"], start_ns, deadline_ns
                )

                await conn.execute(
                    """
                    UPDATE participants
                    SET blitz_index=1
                    WHERE session_id=$1
                    """,
                    s["id"]
                )

                return "ok", int(s["id"]), int(deadline_ns)

    async def record_blitz_answer_and_advance(self, session_code: str, tg_user_id: int, q_index: int, chosen: str) -> \
    Tuple[str, Optional[int]]:
        """
        Records blitz answer if within global blitz deadline.
        Auto-advances per participant: returns (status, next_q_index_or_-1_if_done)
        status: accepted|duplicate|timeout|closed|not_live|not_started
        """
        assert self.pool
        async with self.pool.acquire() as conn:
            async with conn.transaction():
                s = await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1 FOR UPDATE", session_code)
                if not s or s["status"] != "live":
                    return "not_live", None

                await conn.execute("SELECT pg_advisory_xact_lock($1)", int(s["id"]))
                s = await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1 FOR UPDATE", session_code)

                if s["blitz_deadline_ns"] is None or s["blitz_start_ns"] is None:
                    return "not_started", None

                now_ns = time.time_ns()
                if int(now_ns) > int(s["blitz_deadline_ns"]):
                    return "timeout", None

                p = await conn.fetchrow(
                    "SELECT * FROM participants WHERE session_id=$1 AND tg_user_id=$2",
                    s["id"], tg_user_id
                )
                if not p:
                    return "not_in_session", None

                # —É—á–∞—Å—Ç–Ω–∏–∫ –¥–æ–ª–∂–µ–Ω –æ—Ç–≤–µ—á–∞—Ç—å —Å—Ç—Ä–æ–≥–æ –Ω–∞ —Å–≤–æ–π —Ç–µ–∫—É—â–∏–π blitz_index
                expected = int(p["blitz_index"] or 0)
                if expected <= 0:
                    return "closed", None
                if int(q_index) != expected:
                    return "closed", None

                q = await conn.fetchrow(
                    "SELECT correct FROM questions WHERE session_code=$1 AND set='blitz' AND order_index=$2",
                    session_code, q_index
                )
                if not q:
                    return "closed", None

                delta_ns = int(now_ns - int(s["blitz_start_ns"]))
                is_correct = (chosen == q["correct"])

                res = await conn.execute(
                    """
                    INSERT INTO answers(
                      session_id, participant_id, set, question_index,
                      chosen, is_correct, received_ns, delta_ns, answered_after_deadline
                    )
                    VALUES($1,$2,'blitz',$3,$4,$5,$6,$7,false)
                    ON CONFLICT (participant_id, set, question_index) DO NOTHING
                    """,
                    s["id"], p["id"], q_index, chosen, is_correct, now_ns, delta_ns
                )

                if not res.endswith("1"):
                    return "duplicate", None

                # —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å –±–ª–∏—Ü–∞
                total_blitz = await conn.fetchval(
                    "SELECT COUNT(*) FROM questions WHERE session_code=$1 AND set='blitz'",
                    session_code
                )
                total_blitz = int(total_blitz or 0)

                if q_index >= total_blitz:
                    # –±–ª–∏—Ü –∑–∞–≤–µ—Ä—à—ë–Ω –¥–ª—è —ç—Ç–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞
                    await conn.execute("UPDATE participants SET blitz_index=0 WHERE id=$1", p["id"])
                    return "accepted", -1

                next_q = q_index + 1
                await conn.execute("UPDATE participants SET blitz_index=$2 WHERE id=$1", p["id"], next_q)
                return "accepted", next_q

    async def reset_session(self, session_code: str) -> str:
        """
        Deletes participants+answers for session, resets quiz_sessions state to waiting.
        Keeps questions.
        """
        assert self.pool
        async with self.pool.acquire() as conn:
            async with conn.transaction():
                s = await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1 FOR UPDATE", session_code)
                if not s:
                    return "not_found"

                await conn.execute("SELECT pg_advisory_xact_lock($1)", int(s["id"]))

                # —É–¥–∞–ª—è–µ–º –æ—Ç–≤–µ—Ç—ã/—É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
                await conn.execute("DELETE FROM answers WHERE session_id=$1", s["id"])
                await conn.execute("DELETE FROM participants WHERE session_id=$1", s["id"])

                # —Å–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–µ—Å—Å–∏–∏ (–í–ê–ñ–ù–û: —Å–±—Ä–∞—Å—ã–≤–∞–µ–º blitz_* —Ç–æ–∂–µ)
                await conn.execute(
                    """
                    UPDATE quiz_sessions
                    SET status='waiting',
                        current_question_index=0,
                        question_start_ns=NULL,
                        question_deadline_ns=NULL,
                        question_duration_ns=question_duration_ns, -- –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
                        blitz_start_ns=NULL,
                        blitz_deadline_ns=NULL,
                        started_at=NULL,
                        finished_at=NULL
                    WHERE id=$1
                    """,
                    s["id"]
                )
                return "ok"


    async def compute_results(self, session_code: str) -> Tuple[int, List[asyncpg.Record]]:
        assert self.pool
        async with self.pool.acquire() as conn:
            s = await conn.fetchrow("SELECT * FROM quiz_sessions WHERE code=$1", session_code)
            if not s:
                return 0, []
            session_id = s["id"]
            rows = await conn.fetch(
                """
                SELECT
                  p.tg_user_id,
                  COALESCE(p.tg_username,'') AS username,
                  COALESCE(p.display_name,'') AS display_name,
                  COALESCE(SUM(CASE WHEN a.is_correct THEN 1 ELSE 0 END), 0) AS correct_cnt,
                  COALESCE(SUM(CASE WHEN a.is_correct THEN a.delta_ns ELSE 0 END), 0) AS total_ns,
                  COUNT(a.id) AS answered_cnt
                FROM participants p
                LEFT JOIN answers a 
                  ON a.participant_id=p.id 
                 AND a.session_id=$1
                 AND a.set='main'
                WHERE p.session_id=$1
                GROUP BY p.tg_user_id, p.tg_username, p.display_name
                ORDER BY correct_cnt DESC, total_ns ASC, answered_cnt DESC
                """,
                session_id
            )

            total = await conn.fetchval(
                "SELECT COUNT(*) FROM participants WHERE session_id=$1",
                session_id
            )
            return int(total or 0), rows


# --- Bot logic -------------------------------------------------------

db = DB()
admin_watchers: dict[tuple[int, str], asyncio.Task] = {}
admin_watch_state: dict[tuple[int, str], dict] = {}
dp = Dispatcher()

async def broadcast(bot: Bot, user_ids: List[int], text: str, markup=None, batch: int = 25, pause: float = 0.08):
    # –∞–∫–∫—É—Ä–∞—Ç–Ω–æ, —á—Ç–æ–±—ã –Ω–µ —É–ø–µ—Ä–µ—Ç—å—Å—è –≤ rate limit
    for i in range(0, len(user_ids), batch):
        chunk = user_ids[i:i+batch]
        tasks = [bot.send_message(uid, text, reply_markup=markup) for uid in chunk]
        # ignore individual failures
        results = await asyncio.gather(*tasks, return_exceptions=True)
        await asyncio.sleep(pause)

def _ns_left(deadline_ns: Optional[int]) -> Optional[int]:
    if not deadline_ns:
        return None
    return max(0, int(deadline_ns) - int(time.time_ns()))




def build_console_text(
    code: str,
    s,
    joined: int,
    answered_main: int,
    blitz_finished: int,
    blitz_total: int,
    main_total: int
) -> str:
    status_raw = (s["status"] or "waiting").lower()
    status_map = {"waiting": "–û–ñ–ò–î–ê–ù–ò–ï", "live": "–ò–î–Å–¢", "finished": "–ó–ê–í–ï–†–®–ï–ù–ê"}
    status = status_map.get(status_raw, status_raw.upper())

    q_idx = int(s["current_question_index"] or 0)

    left_main_ns = _ns_left(s["question_deadline_ns"]) if status_raw == "live" and q_idx > 0 else None
    left_blitz_ns = _ns_left(s["blitz_deadline_ns"]) if status_raw == "live" and s["blitz_deadline_ns"] else None

    # --- –û–°–ù–û–í–ù–û–ô –ö–í–ò–ó ---
    if main_total <= 0:
        main_block = "–û–°–ù–û–í–ù–´–ï –°–ò–¢–£–ê–¶–ò–ò\n–í–æ–ø—Ä–æ—Å—ã –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã"
    else:
        last_flag = " (–ø–æ—Å–ª–µ–¥–Ω–∏–π)" if (status_raw == "live" and q_idx == main_total and q_idx > 0) else ""
        main_line = f"–í–æ–ø—Ä–æ—Å: {q_idx} –∏–∑ {main_total}{last_flag}"

        if status_raw == "live" and q_idx > 0:
            remaining = max(0, joined - answered_main)
            main_progress = f"–û—Ç–≤–µ—Ç–∏–ª–∏: {answered_main} –∏–∑ {joined} | –û—Å—Ç–∞–ª–æ—Å—å: {remaining}"
        else:
            main_progress = "–û—Ç–≤–µ—Ç—ã: ‚Äî"

        main_time = f"–í—Ä–µ–º—è: {fmt_duration_ns(left_main_ns)}" if left_main_ns is not None else "–í—Ä–µ–º—è: ‚Äî"
        main_block = f"–û–°–ù–û–í–ù–´–ï –°–ò–¢–£–ê–¶–ò–ò\n{main_line}\n{main_progress}\n{main_time}"

    # --- –ë–õ–ò–¶ ---
    blitz_running = bool(s["blitz_start_ns"] and s["blitz_deadline_ns"] and status_raw == "live")
    if blitz_total <= 0:
        blitz_block = "–ë–õ–ò–¶\n–í–æ–ø—Ä–æ—Å—ã –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã"
    else:
        if blitz_running:
            blitz_left = fmt_duration_ns(left_blitz_ns) if left_blitz_ns is not None else "‚Äî"
            blitz_block = (
                "–ë–õ–ò–¶\n"
                "–°—Ç–∞—Ç—É—Å: –∏–¥—ë—Ç\n"
                f"–î–æ –∫–æ–Ω—Ü–∞: {blitz_left}\n"
                f"–ó–∞–≤–µ—Ä—à–∏–ª–∏: {blitz_finished} –∏–∑ {joined}"
            )
        else:
            blitz_block = (
                "–ë–õ–ò–¶\n"
                "–°—Ç–∞—Ç—É—Å: –Ω–µ –∑–∞–ø—É—â–µ–Ω\n"
                f"–í–æ–ø—Ä–æ—Å–æ–≤: {blitz_total}"
            )

    if status_raw == "live":
        if q_idx == 0:
            action_hint = "–î–µ–π—Å—Ç–≤–∏–µ: –Ω–∞–∂–º–∏—Ç–µ ¬´–°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å¬ª, —á—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å 1-–π –≤–æ–ø—Ä–æ—Å."
        elif main_total > 0 and q_idx >= main_total:
            action_hint = "–î–µ–π—Å—Ç–≤–∏–µ: –æ—Å–Ω–æ–≤–Ω—ã–µ —Å–∏—Ç—É–∞—Ü–∏–∏ –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å. –ú–æ–∂–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å ¬´–ò—Ç–æ–≥–∏¬ª –∏–ª–∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å ¬´–ë–ª–∏—Ü¬ª."
        else:
            action_hint = "–î–µ–π—Å—Ç–≤–∏–µ: –Ω–∞–∂–º–∏—Ç–µ ¬´–°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å¬ª, —á—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–π."
    elif status_raw == "waiting":
        action_hint = "–î–µ–π—Å—Ç–≤–∏–µ: –Ω–∞–∂–º–∏—Ç–µ ¬´–°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å¬ª, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∞—Ç–∞–∫—É."
    else:
        action_hint = "–î–µ–π—Å—Ç–≤–∏–µ: –º–æ–∂–Ω–æ –Ω–∞–∂–∞—Ç—å ¬´–ò—Ç–æ–≥–∏¬ª –∏–ª–∏ ¬´–°–±—Ä–æ—Å–∏—Ç—å —Å–µ—Å—Å–∏—é¬ª."

    return (
        f"–ü—É–ª—å—Ç –≤–µ–¥—É—â–µ–≥–æ: {code}\n"
        f"**–°—Ç–∞—Ç—É—Å:** {status}\n\n"
        f"{main_block}\n\n"
        f"{blitz_block}\n\n"
        f"**–£—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –≤ —Å–µ—Å—Å–∏–∏:** {joined}\n\n"
        f"{action_hint}"
    )

async def ensure_admin_watcher(bot: Bot, chat_id: int, message_id: int, code: str):
    """
    –ó–∞–ø—É—Å–∫–∞–µ—Ç/–ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏ (–æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç–µ).
    """
    key = (chat_id, code)

    # –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ä—ã–π watcher
    old = admin_watchers.get(key)
    if old and not old.done():
        old.cancel()

    admin_watch_state[key] = {"message_id": message_id, "last_text": None, "review_sent": False}

    async def _loop():
        while True:
            await asyncio.sleep(2.0)  # —á–∞—Å—Ç–æ—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è

            s = await db.get_session_state(code)
            if not s:
                # –µ—Å–ª–∏ —Å–µ—Å—Å–∏–∏ –Ω–µ—Ç ‚Äî –ø—Ä–µ–∫—Ä–∞—â–∞–µ–º
                return

            st = admin_watch_state.get(key)
            if st and not st.get("review_sent"):
                bs = s["blitz_start_ns"]
                bd = s["blitz_deadline_ns"]

                if s["status"] == "live" and bs and bd:
                    try:
                        start_ns = int(bs)
                        deadline_ns = int(bd)
                    except Exception:
                        start_ns = 0
                        deadline_ns = 0

                    now = time.time_ns()

                    # –≤–∞–ª–∏–¥–Ω—ã–π –±–ª–∏—Ü: deadline > start –∏ —Å—Ç–∞—Ä—Ç —É–∂–µ –±—ã–ª
                    if start_ns > 0 and deadline_ns > start_ns and now >= start_ns:
                        # –∑–∞—â–∏—Ç–∞ –æ—Ç "—Å—Ç–∞—Ä—ã—Ö" –¥–µ–¥–ª–∞–π–Ω–æ–≤: —Ä–µ–∞–≥–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∑–∞–∫–æ–Ω—á–∏–ª–æ—Å—å –Ω–µ–¥–∞–≤–Ω–æ
                        if now >= deadline_ns and (now - deadline_ns) <= 15_000_000_000:  # 15 —Å–µ–∫—É–Ω–¥
                            kb = InlineKeyboardMarkup(inline_keyboard=[
                                [InlineKeyboardButton(text="üìò –†–∞–∑–æ—Å–ª–∞—Ç—å —Ä–∞–∑–±–æ—Ä —É—á–∞—Å—Ç–Ω–∏–∫–∞–º",
                                                      callback_data=f"revsend:{code}")]
                            ])
                            try:
                                await bot.send_message(
                                    chat_id,
                                    "‚ö° –ë–ª–∏—Ü –∑–∞–≤–µ—Ä—à—ë–Ω. –ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã —Ä–∞–∑–æ—Å–ª–∞—Ç—å —Ä–∞–∑–±–æ—Ä –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º:",
                                    reply_markup=kb
                                )
                            finally:
                                st["review_sent"] = True

            session_id = int(s["id"])
            joined = await db.get_participant_stats(session_id)

            main_total = await db.get_questions_count(code, set_name="main")
            blitz_total = await db.get_questions_count(code, set_name="blitz")

            q_idx = int(s["current_question_index"] or 0)
            answered_main = 0
            if s["status"] == "live" and q_idx > 0:
                answered_main = await db.count_answered_for_question(session_id, q_idx, set_name="main")

            blitz_finished = 0
            if s["status"] == "live" and s["blitz_start_ns"] and s["blitz_deadline_ns"]:
                blitz_finished = await db.count_blitz_finished(session_id)

            text = build_console_text(
                code=code,
                s=s,
                joined=joined,
                answered_main=answered_main,
                blitz_finished=blitz_finished,
                blitz_total=blitz_total,
                main_total=main_total
            )

            st = admin_watch_state.get(key)
            if not st:
                return

            if text == st.get("last_text"):
                continue  # –Ω–µ –¥—ë—Ä–≥–∞–µ–º Telegram –ª–∏—à–Ω–∏–π —Ä–∞–∑

            msg_id = int(st["message_id"])
            try:
                await bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=msg_id,
                    text=text,
                    reply_markup=admin_menu_kb(code),
                    parse_mode="Markdown",
                )
                st["last_text"] = text
            except Exception:
                # –ï—Å–ª–∏ edit –Ω–µ–ª—å–∑—è (—Å—Ç–∞—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ / —É–¥–∞–ª–µ–Ω–æ / etc) ‚Äî –æ—Ç–ø—Ä–∞–≤–∏–º –Ω–æ–≤–æ–µ –∏ –ø—Ä–æ–¥–æ–ª–∂–∏–º –Ω–∞ –Ω—ë–º
                try:
                    m = await bot.send_message(
                        chat_id,
                        text,
                        reply_markup=admin_menu_kb(code),
                        parse_mode="Markdown",
                    )
                    st["message_id"] = m.message_id
                    st["last_text"] = text
                except Exception:
                    return

    admin_watchers[key] = asyncio.create_task(_loop())


async def send_main_question_to_user(bot: Bot, session_code: str, user_id: int, q_index: int):
    q = await db.get_question(session_code, q_index, set_name="main")
    if not q:
        return
    text = (
        f"**–í–æ–ø—Ä–æ—Å {q.order_index}**\n"
        f"{q.text}\n\n"
        f"A) {q.a}\n"
        f"B) {q.b}\n"
        f"C) {q.c}\n"
        f"D) {q.d}\n"
    )
    await bot.send_message(user_id, text, reply_markup=answer_kb(session_code, q_index))


async def send_question_to_active(bot: Bot, session_code: str, session_id: int, q_index: int):

    q = await db.get_question(session_code, q_index, set_name="main")
    if not q:
        return

    main_total = await db.get_questions_count(session_code, set_name="main")
    tail = "\nüèÅ **–û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–æ–ø—Ä–æ—Å, —á—Ç–æ–±—ã –Ω–µ–π—Ç—Ä–∞–ª–∏–∑–æ–≤–∞—Ç—å –∞—Ç–∞–∫—É!**" if q_index == main_total else ""

    text = (
        f"**–í–æ–ø—Ä–æ—Å {q.order_index}/{main_total}**\n"
        f"{q.text}\n\n"
        f"A) {q.a}\n"
        f"B) {q.b}\n"
        f"C) {q.c}\n"
        f"D) {q.d}\n"
        f"{tail}"
    )

    user_ids = await db.get_session_users(session_id)

    if TEST_MODE and TEST_USER_ID not in user_ids:
        user_ids.append(TEST_USER_ID)

    if not TEST_MODE:
        user_ids = [uid for uid in user_ids if uid not in ADMIN_IDS]

    await broadcast(bot, user_ids, text, markup=answer_kb(session_code, q_index))


async def send_blitz_question_to_user(bot: Bot, session_code: str, user_id: int, q_index: int):
    q = await db.get_question(session_code, q_index, set_name="blitz")
    if not q:
        return

    total_blitz = await db.get_questions_count(session_code, set_name="blitz")
    tail = "\n\nüèÅ **–≠—Ç–æ –ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–æ–ø—Ä–æ—Å –±–ª–∏—Ü–∞!**" if q_index == total_blitz else ""

    text = (
        f"‚ö° **–ë–õ–ò–¶ ‚Äî –í–æ–ø—Ä–æ—Å {q.order_index}/{total_blitz}**\n"
        f"{q.text}\n\n"
        f"A) {q.a}\n"
        f"B) {q.b}\n"
        f"C) {q.c}\n"
        f"D) {q.d}\n\n"
        f"‚è±Ô∏è –£ –≤–∞—Å –æ–±—â–∏–π –ª–∏–º–∏—Ç 2 –º–∏–Ω—É—Ç—ã –Ω–∞ –≤–µ—Å—å –±–ª–∏—Ü."
        f"{tail}"
    )
    await bot.send_message(user_id, text, reply_markup=blitz_answer_kb(session_code, q_index))


TOP10_MSG = "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –Ω–∞–±—Ä–∞–ª–∏ –Ω–∞–∏–±–æ–ª—å—à–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∞–ª–ª–æ–≤ –∏ –∑–∞—á–∏—Å–ª–µ–Ω—ã –Ω–∞ —É–≥–ª—É–±–ª—ë–Ω–Ω—É—é –æ–±—É—á–∞—é—â—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É –ò–§–¢–ü-2026 –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –æ—Ç–±–æ—Ä–∞."
OTHERS_MSG = "–°–ø–∞—Å–∏–±–æ –∑–∞ –∏–≥—Ä—É! –í—ã –ø—Ä–∏–≥–ª–∞—à–µ–Ω—ã –Ω–∞ –æ–±—â—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É –ò–§–¢–ü-2026. –ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ –Ω–∞—à–µ–º—É —á–∞—Ç—É, –≤–ø–µ—Ä–µ–¥–∏ –µ—â—ë –º–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–≥–æ."
TOP5_MSG = "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –≤–æ—à–ª–∏ –≤ —Ç–æ–ø-5 –ø–æ –∏—Ç–æ–≥–∞–º —Ä–µ—à–µ–Ω–∏—è –∫–µ–π—Å–∞ –∏ –±–ª–∏—Ü–∞!"


def _who(r) -> str:
    uname = r["username"]
    name = r["display_name"]
    return f"@{uname}" if uname else (name if name else str(r["tg_user_id"]))


async def finish_and_send_results(bot: Bot, session_code: str, admin_chat_id: int):
    # 1) –õ–∏–¥–µ—Ä–±–æ—Ä–¥ (–≤—Å–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏) + –æ—Ç–¥–µ–ª—å–Ω–æ —Ç–æ–ø10 –¥–ª—è –≤–µ–¥—É—â–µ–≥–æ
    total_roster, all_rows = await db.compute_leaderboard(session_code, limit=None)
    _, top10_rows = await db.compute_leaderboard(session_code, limit=10)

    # 2) –í–µ–¥—É—â–µ–º—É –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –¢–û–ü-10
    lines = [f"**–¢–û–ü-10: {session_code}**", f"–£—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {total_roster}", ""]
    rank = 1
    for r in top10_rows:
        lines.append(
            f"{rank}) {_who(r)} ‚Äî {int(r['correct_cnt'])} –±–∞–ª–ª–æ–≤ ‚Äî {fmt_duration_ns(int(r['total_ns']))}"
        )
        rank += 1
    await send_long(bot, admin_chat_id, "\n".join(lines))


# --- Handlers --------------------------------------------------------


@dp.message(Command("start"))
async def cmd_start(message: Message, command: CommandObject):
    args = (command.args or "").strip()
    code = (args or EVENT_CODE).strip()

    # –ê–¥–º–∏–Ω: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—É–ª—å—Ç
    if is_admin(message.from_user.id):
        s = await db.get_session(code)
        if not s:
            if code == EVENT_CODE:
                s = await db.create_session(code)
            else:
                return await message.answer("–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–¥/QR.")

        # TEST_MODE
        if TEST_MODE:
            display_name = message.from_user.full_name
            username = message.from_user.username
            await db.join_participant(int(s["id"]), int(message.from_user.id), username, display_name)

        m = await message.answer(
            f"üéõ –ü—É–ª—å—Ç –≤–µ–¥—É—â–µ–≥–æ",
            reply_markup=admin_menu_kb(code)
        )
        await ensure_admin_watcher(bot=message.bot, chat_id=m.chat.id, message_id=m.message_id, code=code)

        # TEST_MODE
        if TEST_MODE:
            s2 = await db.get_session_state(code)
            if s2 and s2["status"] == "live":
                # –¢–µ–∫—É—â–∏–π –≤–æ–ø—Ä–æ—Å main, –µ—Å–ª–∏ –æ–∫–Ω–æ –µ—â—ë –æ—Ç–∫—Ä—ã—Ç–æ
                q_idx = int(s2["current_question_index"] or 0)
                if q_idx > 0:
                    deadline_ns = s2.get("question_deadline_ns")
                    if deadline_ns is None or time.time_ns() <= int(deadline_ns):
                        try:
                            await send_main_question_to_user(message.bot, code, message.from_user.id, q_idx)
                        except Exception:
                            pass

                # –ë–ª–∏—Ü, –µ—Å–ª–∏ –∑–∞–ø—É—â–µ–Ω –∏ –≤—Ä–µ–º—è –µ—â—ë –µ—Å—Ç—å
                blitz_start = s2.get("blitz_start_ns")
                blitz_deadline = s2.get("blitz_deadline_ns")
                if blitz_start and blitz_deadline and time.time_ns() <= int(blitz_deadline):
                    try:
                        await db.set_blitz_index_for_user(int(s["id"]), int(message.from_user.id), 1)
                        await send_blitz_question_to_user(message.bot, code, message.from_user.id, 1)
                    except Exception:
                        pass

        return

    # –£—á–∞—Å—Ç–Ω–∏–∫: –∞–≤—Ç–æ-–≤—Ö–æ–¥

    s = await db.get_session(code)
    if not s:
        if code == EVENT_CODE:
            s = await db.create_session(code)
        else:
            return await message.answer("–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ QR-–∫–æ–¥ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –≤–µ–¥—É—â–µ–º—É.")

    display_name = message.from_user.full_name
    username = message.from_user.username
    p = await db.join_participant(int(s["id"]), int(message.from_user.id), username, display_name)

    s2 = await db.get_session_state(code)
    if not s2:
        s2 = s

    if s2["status"] == "finished":
        return await message.answer("‚úÖ –≠—Ç–∞ —Å–µ—Å—Å–∏—è —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")

    # –ë–∞–∑–æ–≤–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ
    if bool(p["inserted"]):
        await message.answer(
            "üëã –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ–º –≤–∞—Å –≤ —á–∞—Ç–µ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–∞:\n"
            f"'<–ö–µ–π—Å—ã —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∫–∏–±–µ—Ä—É–≥—Ä–æ–∑ –∏–ª–∏ –≤–æ–∑—å–º–∏ –º–æ–π —Ñ–∏–Ω–≥–µ—Ä–ø—Ä–∏–Ω—Ç!>\n"
        )
    else:
        await message.answer(
            f"‚úÖ –í—ã —É–∂–µ —É—á–∞—Å—Ç–≤—É–µ—Ç–µ.\n"
            "–û—Å—Ç–∞–≤–∞–π—Ç–µ—Å—å –∑–¥–µ—Å—å."
        )

    if s2["status"] == "live":
        # –¢–µ–∫—É—â–∏–π –≤–æ–ø—Ä–æ—Å main, –µ—Å–ª–∏ –æ–∫–Ω–æ –µ—â—ë –æ—Ç–∫—Ä—ã—Ç–æ
        q_idx = int(s2["current_question_index"] or 0)
        if q_idx > 0:
            deadline_ns = s2.get("question_deadline_ns")
            if deadline_ns is None or time.time_ns() <= int(deadline_ns):
                try:
                    await send_main_question_to_user(message.bot, code, message.from_user.id, q_idx)
                except Exception:
                    pass

        # –ë–ª–∏—Ü, –µ—Å–ª–∏ –∑–∞–ø—É—â–µ–Ω –∏ –≤—Ä–µ–º—è –µ—â—ë –µ—Å—Ç—å
        blitz_start = s2.get("blitz_start_ns")
        blitz_deadline = s2.get("blitz_deadline_ns")
        if blitz_start and blitz_deadline and time.time_ns() <= int(blitz_deadline):
            try:
                await db.set_blitz_index_for_user(int(s["id"]), int(message.from_user.id), 1)
                await send_blitz_question_to_user(message.bot, code, message.from_user.id, 1)
            except Exception:
                pass

@dp.callback_query(F.data.startswith("rev:menu:"))
async def rev_menu(call: CallbackQuery):
    code = call.data.split(":", 2)[2]
    await call.message.edit_text(
        f"<b>üìò –†–∞–∑–±–æ—Ä –ê—Ç–∞–∫–∏ –∏ –ë–ª–∏—Ü–∞</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:",
        parse_mode="HTML",
        reply_markup=kb_review_root(code),
    )
    await call.answer()

@dp.callback_query(F.data.startswith("revsend:"))
async def on_review_send(call: CallbackQuery):
    # revsend:<code>
    code = call.data.split(":", 1)[1]

    s = await db.get_session_state(code)
    if not s:
        await call.answer("–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
        return

    session_id = int(s["id"])

    # (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –Ω–æ –ø–æ–ª–µ–∑–Ω–æ) –∑–∞—â–∏—Ç–∞: —Ç–æ–ª—å–∫–æ —Ç–æ—Ç —á–∞—Ç, –≥–¥–µ –ø–∞–Ω–µ–ª—å –≤–µ–¥—É—â–µ–≥–æ
    # –µ—Å–ª–∏ —É —Ç–µ–±—è admin_chat_id —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ quiz_sessions:
    admin_chat_id = s.get("admin_chat_id")
    if admin_chat_id and int(admin_chat_id) != int(call.message.chat.id):
        await call.answer("–¢–æ–ª—å–∫–æ –≤–µ–¥—É—â–∏–π –º–æ–∂–µ—Ç —Ä–∞–∑–æ—Å–ª–∞—Ç—å —Ä–∞–∑–±–æ—Ä", show_alert=True)
        return

    user_ids = await db.get_session_users(session_id)
    if not user_ids:
        await call.answer("–ù–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏", show_alert=True)
        return

    sent, failed = 0, 0
    for uid in user_ids:
        try:
            await call.message.bot.send_message(
                uid,
                "üìò <b>–†–∞–∑–±–æ—Ä –∞—Ç–∞–∫–∏</b>\n–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:",
                parse_mode="HTML",
                reply_markup=kb_review_root(code),
            )
            sent += 1
            await asyncio.sleep(0.03)  # —á—Ç–æ–±—ã –Ω–µ —É–ø–µ—Ä–µ—Ç—å—Å—è –≤ –ª–∏–º–∏—Ç—ã
        except Exception:
            failed += 1

    await call.message.answer(f"‚úÖ –†–∞–∑–±–æ—Ä —Ä–∞–∑–æ—Å–ª–∞–Ω: {sent}, –æ—à–∏–±–æ–∫: {failed}.")
    await call.answer("–ì–æ—Ç–æ–≤–æ")


@dp.callback_query(F.data.startswith("broadcast:"))
async def on_broadcast(call: CallbackQuery):
    # broadcast:<all|top10|top5>:<code>
    parts = call.data.split(":")
    mode = parts[1]
    code = parts[2]

    s = await db.get_session_state(code)
    if not s:
        await call.answer("–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
        return

    session_id = int(s["id"])

    # 1) –ø–æ–ª—É—á–∞—Ç–µ–ª–∏
    if mode == "all":
        user_ids = await db.get_session_users(session_id)
        text = MSG_ALL
    elif mode == "top10":
        _, rows = await db.compute_leaderboard(code, limit=10)
        user_ids = [int(r["tg_user_id"]) for r in rows]
        text = MSG_TOP10
    elif mode == "top5":
        _, rows = await db.compute_leaderboard(code, limit=5)
        user_ids = [int(r["tg_user_id"]) for r in rows]
        text = MSG_TOP5
    else:
        await call.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞", show_alert=True)
        return

    # 2) —Ä–∞—Å—Å—ã–ª–∫–∞
    sent = 0
    failed = 0
    first_err = None

    for uid in user_ids:
        try:
            await call.message.bot.send_message(
                uid,
                text,
                parse_mode="HTML",  # <-- –í–ê–ñ–ù–û: –æ—Ç–∫–ª—é—á–∞–µ–º Markdown –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                disable_web_page_preview=True  # –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
            )
            sent += 1
        except Exception as e:
            failed += 1
            if first_err is None:
                first_err = repr(e)

    await call.answer("–ì–æ—Ç–æ–≤–æ")
    msg = f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞: –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {sent}, –æ—à–∏–±–æ–∫ {failed}."
    if first_err:
        msg += f"\n\n‚ö†Ô∏è –ü–µ—Ä–≤–∞—è –æ—à–∏–±–∫–∞:\n{first_err}"
    await call.message.answer(msg)


@dp.callback_query(F.data.startswith("rev:set:"))
async def rev_set(call: CallbackQuery):
    # rev:set:<code>:<main|blitz>
    parts = call.data.split(":")
    code = parts[2]
    set_name = parts[3]
    title = "üéØ –ê—Ç–∞–∫–∞" if set_name == "main" else "‚ö° –ë–ª–∏—Ü"
    await call.message.edit_text(
        f"<b>{title}</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –≤–æ–ø—Ä–æ—Å:",
        parse_mode="HTML",
        reply_markup=kb_review_set(code, set_name),
    )
    await call.answer()


@dp.callback_query(F.data.startswith("rev:q:"))
async def rev_question(call: CallbackQuery):
    # rev:q:<code>:<main|blitz>:<idx>
    parts = call.data.split(":")
    code = parts[2]
    set_name = parts[3]
    idx = int(parts[4])

    text = render_question_text(set_name, idx)
    await call.message.edit_text(
        text,
        parse_mode="HTML",
        reply_markup=kb_review_question(code, set_name, idx),
        disable_web_page_preview=True,
    )
    await call.answer()


@dp.callback_query(F.data.startswith("rev:e:"))
async def rev_explanations(call: CallbackQuery):
    # rev:e:<code>:<main|blitz>:<idx>
    parts = call.data.split(":")
    code = parts[2]
    set_name = parts[3]
    idx = int(parts[4])

    text = render_explanations_text(set_name, idx)
    await call.message.edit_text(
        text,
        parse_mode="HTML",
        reply_markup=kb_review_explanations(code, set_name, idx),
        disable_web_page_preview=True,
    )
    await call.answer()


@dp.callback_query(F.data.startswith("rev:close:"))
async def rev_close(call: CallbackQuery):
    await call.message.edit_text("üìò –†–∞–∑–±–æ—Ä –∑–∞–∫—Ä—ã—Ç.", reply_markup=None)
    await call.answer()

@dp.message(Command("admin"))
async def cmd_admin(message: Message):
    if not is_admin(message.from_user.id):
        return await message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")

    # –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ —Å–µ—Å—Å–∏—è –µ—Å—Ç—å (–Ω–∞ –≤—Å—è–∫–∏–π)
    await db.ensure_event(EVENT_CODE, QUESTION_DURATION_NS)

    m = await message.answer(
        f"üéõ **–ü—É–ª—å—Ç –≤–µ–¥—É—â–µ–≥–æ ‚Äî {EVENT_CODE}**",
        reply_markup=admin_menu_kb(EVENT_CODE)
    )
    await ensure_admin_watcher(bot=message.bot, chat_id=m.chat.id, message_id=m.message_id, code=EVENT_CODE)


@dp.callback_query(F.data.startswith("admopen:"))
async def open_admin_session(call: CallbackQuery):
    if not is_admin(call.from_user.id):
        return await call.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", show_alert=True)

    code = call.data.split(":")[1]

    await call.message.edit_text(
        f"üéõ **–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å**",
        reply_markup=admin_menu_kb(code)
    )

    await ensure_admin_watcher(bot=call.bot, chat_id=call.message.chat.id, message_id=call.message.message_id, code=code)
    await call.answer()

@dp.message(Command("next"))
async def cmd_next(message: Message, command: CommandObject, bot: Bot):
    if not is_admin(message.from_user.id):
        return await message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
    code = (command.args or "").strip()
    if not code:
        return await message.answer("–ü—Ä–∏–º–µ—Ä: /next CONF2026")

    status, session_id, new_q, deadline_ns = await db.start_next_question(code)

    if status == "not_live":
        return await message.answer("–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –°–Ω–∞—á–∞–ª–∞ /create_session CODE")
    if status == "no_questions":
        return await message.answer("–ù–µ—Ç –≤–æ–ø—Ä–æ—Å–æ–≤. –°–Ω–∞—á–∞–ª–∞ /load_questions CODE file.json")
    if status == "finished" or new_q == -1:
        # –æ—Ç–ø—Ä–∞–≤–∏–º –∏—Ç–æ–≥–∏ –∞–¥–º–∏–Ω—É
        await message.answer("–í–æ–ø—Ä–æ—Å—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å. –û—Ç–ø—Ä–∞–≤–ª—è—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã‚Ä¶")
        await finish_and_send_results(bot, code, message.chat.id)
        return

    # –†–∞—Å—Å—ã–ª–∞–µ–º –≤–æ–ø—Ä–æ—Å
    await send_question_to_active(bot, code, session_id, new_q)

    # –ü–∏—à–µ–º –∞–¥–º–∏–Ω—É –¥–µ–¥–ª–∞–π–Ω
    now_ns = time.time_ns()
    left_ns = max(0, int(deadline_ns) - int(now_ns))
    await message.answer(f"–í–æ–ø—Ä–æ—Å {new_q} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω. –û–∫–Ω–æ –æ—Ç–≤–µ—Ç–∞: {fmt_duration_ns(left_ns)}")

@dp.message(Command("create_session"))
async def cmd_create_session(message: Message, command: CommandObject):
    if not is_admin(message.from_user.id):
        return await message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
    code = (command.args or "").strip()
    if not code:
        return await message.answer("–ü—Ä–∏–º–µ—Ä: /create_session CONF2026")
    s = await db.create_session(code)
    await message.answer(f"–°–æ–∑–¥–∞–Ω–æ/–æ–±–Ω–æ–≤–ª–µ–Ω–æ: {s['code']}. –°—Ç–∞—Ç—É—Å: {s['status']}")

@dp.message(Command("load_questions"))
async def cmd_load_questions(message: Message, command: CommandObject):
    if not is_admin(message.from_user.id):
        return await message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
    args = (command.args or "").strip().split()
    if len(args) != 2:
        return await message.answer("–ü—Ä–∏–º–µ—Ä: /load_questions CONF2026 questions_CONF2026.json")
    code, filename = args
    await db.load_questions_from_json(code, filename)
    cnt = await db.get_questions_count(code)
    await message.answer(f"–û–∫. –í–æ–ø—Ä–æ—Å–æ–≤ –¥–ª—è {code}: {cnt}")


@dp.message(Command("status"))
async def cmd_status(message: Message, command: CommandObject):
    if not is_admin(message.from_user.id):
        return await message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
    code = (command.args or "").strip()
    if not code:
        return await message.answer("–ü—Ä–∏–º–µ—Ä: /status CONF2026")
    s = await db.get_session_state(code)
    if not s:
        return await message.answer("–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")

    joined = await db.get_participant_stats(int(s["id"]))
    await message.answer(
        f"–°–µ—Å—Å–∏—è {code}\n"
        f"–°—Ç–∞—Ç—É—Å: {s['status']}\n"
        f"–¢–µ–∫—É—â–∏–π –≤–æ–ø—Ä–æ—Å: {s['current_question_index']}\n"
        f"–£—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {joined}"
    )

@dp.message(Command("finish"))
async def cmd_finish(message: Message, command: CommandObject, bot: Bot):
    if not is_admin(message.from_user.id):
        return await message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
    code = (command.args or "").strip()
    if not code:
        return await message.answer("–ü—Ä–∏–º–µ—Ä: /finish CONF2026")
    # –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    await finish_and_send_results(bot, code, message.chat.id)

@dp.callback_query(F.data.startswith("adm:"))
async def on_admin_action(call: CallbackQuery, bot: Bot):
    if not is_admin(call.from_user.id):
        return await call.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", show_alert=True)

    try:
        _, action, code = call.data.split(":", 2)
    except Exception:
        return await call.answer("–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö.", show_alert=True)

    # –≤—Å–µ–≥–¥–∞ –¥–µ—Ä–∂–∏–º –º–µ–Ω—é –ø–æ–¥ —Ä—É–∫–æ–π
    async def refresh_menu(_unused: Optional[str] = None):
        await ensure_admin_watcher(
            bot=bot,
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            code=code
        )

    if action == "next":
        status, session_id, new_q, deadline_ns = await db.start_next_question(code)

        if status == "not_live":
            await call.answer("–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", show_alert=True)
            return
        if status == "no_questions":
            await call.answer("–ù–µ—Ç –≤–æ–ø—Ä–æ—Å–æ–≤.", show_alert=True)
            return
        if status == "finished" or new_q == -1:
            await call.answer("–í–æ–ø—Ä–æ—Å—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å.", show_alert=True)
            await finish_and_send_results(bot, code, call.message.chat.id)
            await refresh_menu("–í–æ–ø—Ä–æ—Å—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å. –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã.")
            return

        await send_question_to_active(bot, code, session_id, new_q)

        main_total = await db.get_questions_count(code, set_name="main")
        if new_q == main_total:
            await call.answer("üèÅ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω –ü–û–°–õ–ï–î–ù–ò–ô –≤–æ–ø—Ä–æ—Å main ‚úÖ", show_alert=True)
        else:
            await call.answer("–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ ‚úÖ")
        await refresh_menu()
        return

        left_ns = max(0, int(deadline_ns) - int(time.time_ns()))
        await refresh_menu(f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤–æ–ø—Ä–æ—Å **{new_q}**.\n–û–∫–Ω–æ –æ—Ç–≤–µ—Ç–∞: **{fmt_duration_ns(left_ns)}**")
        return


    if action == "blitz":
        st, session_id, deadline_ns = await db.start_blitz(code)
        if st == "not_live":
            await call.answer("–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", show_alert=True)
            return
                # —Ä–∞—Å—Å—ã–ª–∞–µ–º Q1 –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º —Å–µ—Å—Å–∏–∏ (–∫—Ä–æ–º–µ –∞–¥–º–∏–Ω–æ–≤)
        user_ids = await db.get_session_users(session_id)
        user_ids = [uid for uid in user_ids if uid not in ADMIN_IDS]
        for uid in user_ids:
            try:
                await send_blitz_question_to_user(bot, code, uid, 1)
            except Exception:
                pass

        left_ns = max(0, int(deadline_ns) - int(time.time_ns()))
        await call.answer("–ë–ª–∏—Ü –∑–∞–ø—É—â–µ–Ω ‚úÖ", show_alert=True)
        await refresh_menu(
            f"‚ö° –ë–ª–∏—Ü –∑–∞–ø—É—â–µ–Ω.\n–û–±—â–∏–π —Ç–∞–π–º–µ—Ä: **{fmt_duration_ns(left_ns)}**.\n–í–æ–ø—Ä–æ—Å—ã –∏–¥—É—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ –æ—Ç–≤–µ—Ç—É.")
        return

    if action == "finish":
        await call.answer("–°–æ–±–∏—Ä–∞—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã‚Ä¶")
        await finish_and_send_results(bot, code, call.message.chat.id)
        await refresh_menu("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã.")
        return

    if action == "reset":
        await call.answer("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Å–±—Ä–æ—Å")

        await call.message.edit_text(
            f"‚ö†Ô∏è **–°–±—Ä–æ—Å–∏—Ç—å —Å–µ—Å—Å–∏—é?**\n\n"
            f"–ë—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã:\n"
            f"‚Ä¢ –≤—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏\n"
            f"‚Ä¢ –≤—Å–µ –æ—Ç–≤–µ—Ç—ã\n\n"
            f"–í–æ–ø—Ä–æ—Å—ã –æ—Å—Ç–∞–Ω—É—Ç—Å—è.",
            reply_markup=confirm_reset_kb(code)
        )
        return


    if action == "reset_no":
        await call.answer("–û—Ç–º–µ–Ω–µ–Ω–æ")
        await refresh_menu("–°–±—Ä–æ—Å –æ—Ç–º–µ–Ω—ë–Ω.")
        return


    if action == "reset_yes":
        res = await db.reset_session(code)

        if res != "ok":
            await call.answer("–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", show_alert=True)
            return

        await call.answer("–°–µ—Å—Å–∏—è —Å–±—Ä–æ—à–µ–Ω–∞ ‚úÖ", show_alert=True)

        await refresh_menu(
            "üî• –°–µ—Å—Å–∏—è –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–µ–Ω–∞.\n"
            "–ú–æ–∂–Ω–æ —Å–Ω–æ–≤–∞ –∂–∞—Ç—å üöÄ Launch."
        )
        return


    await call.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞.", show_alert=True)

@dp.callback_query(F.data.startswith("blitz:"))
async def on_blitz_answer(call: CallbackQuery, bot: Bot):
    try:
        _, code, q_idx_s, chosen = call.data.split(":")
        q_idx = int(q_idx_s)
    except Exception:
        return await call.answer("–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö.", show_alert=True)

    status, next_q = await db.record_blitz_answer_and_advance(code, call.from_user.id, q_idx, chosen)

    async def disable_answer_buttons():
        try:
            await call.message.edit_reply_markup(reply_markup=None)
        except Exception:
            pass

    if status == "accepted":
        await disable_answer_buttons()
        await call.answer("–ü—Ä–∏–Ω—è—Ç–æ ‚úÖ")

        if next_q == -1:
            try:
                await bot.send_message(call.from_user.id, "‚ö° –ë–ª–∏—Ü –∑–∞–≤–µ—Ä—à—ë–Ω! –°–ø–∞—Å–∏–±–æ üòä –ñ–¥–∏—Ç–µ –æ–±—â–∏—Ö –∏—Ç–æ–≥–æ–≤.")
            except Exception:
                pass
            return

        await send_blitz_question_to_user(bot, code, call.from_user.id, next_q)
        return

    if status == "duplicate":
        await disable_answer_buttons()
        return await call.answer("–£–∂–µ –ø—Ä–∏–Ω—è—Ç–æ ‚úÖ")  # –±–µ–∑ show_alert

    if status == "timeout":
        await disable_answer_buttons()
        return await call.answer("‚è±Ô∏è –í—Ä–µ–º—è –±–ª–∏—Ü–∞ –≤—ã—à–ª–æ.", show_alert=True)

    if status == "not_started":
        return await call.answer("–ë–ª–∏—Ü –µ—â—ë –Ω–µ –∑–∞–ø—É—â–µ–Ω.", show_alert=True)

    if status == "closed":
        await disable_answer_buttons()
        return await call.answer("–≠—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å —É–∂–µ –∑–∞–∫—Ä—ã—Ç.", show_alert=True)

    if status == "not_in_session":
        return await call.answer("–í—ã –Ω–µ —É—á–∞—Å—Ç–≤—É–µ—Ç–µ –≤ —Å–µ—Å—Å–∏–∏.", show_alert=True)

    return await call.answer("–°–µ—Å—Å–∏—è –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞.", show_alert=True)



@dp.callback_query(F.data.startswith("ans:"))
async def on_answer(call: CallbackQuery, bot: Bot):
    try:
        _, code, q_idx_s, chosen = call.data.split(":")
        q_idx = int(q_idx_s)
    except Exception:
        return await call.answer("–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö.", show_alert=True)

    status = await db.record_answer_and_maybe_advance(
        session_code=code,
        tg_user_id=call.from_user.id,
        q_index=q_idx,
        chosen=chosen
    )

    # helper: –æ—Ç–∫–ª—é—á–∞–µ–º –∫–Ω–æ–ø–∫–∏, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –∫–ª–∏–∫–æ–≤
    async def disable_answer_buttons():
        try:
            await call.message.edit_reply_markup(reply_markup=None)
        except Exception:
            pass

    if status == "accepted":
        await disable_answer_buttons()
        await call.answer("–ü—Ä–∏–Ω—è—Ç–æ ‚úÖ")

        main_total = await db.get_questions_count(code, set_name="main")
        if q_idx == main_total:
            try:
                await bot.send_message(
                    call.from_user.id,
                    "‚úÖ –≠—Ç–æ –±—ã–ª –ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–æ–ø—Ä–æ—Å –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∫–µ–π—Å–∞. –û—Ç–≤–µ—Ç—ã –±—É–¥—É—Ç –≤ –∫–æ–Ω—Ü–µ"
                )
            except Exception:
                pass
        return

    if status == "duplicate":
        await disable_answer_buttons()
        return await call.answer("–£–∂–µ –ø—Ä–∏–Ω—è—Ç–æ ‚úÖ")  # –±–µ–∑ show_alert, —á—Ç–æ–±—ã –Ω–µ –±–µ—Å–∏—Ç—å

    if status == "timeout":
        await disable_answer_buttons()
        return await call.answer("–í—Ä–µ–º—è –≤—ã—à–ª–æ ‚è±Ô∏è", show_alert=True)

    if status == "closed":
        await disable_answer_buttons()
        return await call.answer("–≠—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å —É–∂–µ –∑–∞–∫—Ä—ã—Ç.", show_alert=True)

    if status == "not_in_session":
        return await call.answer("–í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —ç—Ç–æ–π —Å–µ—Å—Å–∏–∏. –ù–∞–∂–º–∏—Ç–µ /start.", show_alert=True)

    return await call.answer("–°–µ—Å—Å–∏—è –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞.", show_alert=True)




# --- Entrypoint ------------------------------------------------------

async def main():
    bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode="Markdown"))
    await db.connect()
    await db.init_schema()
    await db.ensure_event(EVENT_CODE, QUESTION_DURATION_NS)
    await db.load_questions_from_json(EVENT_CODE, QUESTIONS_FILE)
    await db.load_blitz_from_const(EVENT_CODE)

    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
